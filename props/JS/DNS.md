`Сайт`состоит из `файлов` которые `хранятся` на другом компьютере в сети - `на сервере`. Чтобы `достучаться` до другого компа(`сервера`) нужно знать его `ip-адрес`.

`DNS` - это аналог огромной `телефонной книги`. Он позволяет найти `ip-адрес` сайта по его `доменному имени`. DNS - `Domain Name System` (система доменных имен)

![[Pasted image 20231114193122.png]]

### _Структура DNS_

Структура `DNS` является иерархической. Она выделяет зоны ответственности, где каждый родитель знает о расположении своего дочернего сервера, и знает зону его ответственности.

То есть DNS-сервер домена `.io` знает о том, где расположен домен `hexlet`, DNS-сервер которого знает о расположении своих поддоменов.

![[Pasted image 20231114211025.png]]

### _Что происходит при поиске?_

1. При вводе `доменного имени` сайта, мы начинаем `поиск` `адреса` его `сервера` - `ip`
2. Сначала ищем локально, в `кеше` и в файле `hosts`
3. Если ничего не нашли, то обращаемся к `DNS Resolver`(он так же проверяет свой кеш)
   Обычно резолвер-сервер это твой интернет-провайдер (`ISP`). Или вручную установленный `DNS` от Google (`8.8.8.8`), Cloudflare (`1.1.1.1`) и тд.
   Все резолверы должны `знать` одно: где найти `корневой сервер`.

![[Pasted image 20231114214341.png]]

4. Обращаемся к `Root-серверу` - хранилищу верхнеуровневых(`TLD`) доменов 
   
![[Pasted image 20231114212906.png]]
   
5. `Root-сервер` не знает к кому принадлежит конкретное `доменное имя`, но знает 
   `TLD`(`top level domain`) `сервер верхнего уровня`, который знает где найти данный сайт.

![[Pasted image 20231114215749.png]]

6. `TLD-сревер` тоже не знает где точно найти сайт и направляет нас на `Host-сервер`, туда где наш сайт арендует цифровое пространство.
   
   Обычно за каждым `доменом` закреплено более одного `именного сервера`. Несколько `серверов-дубликатов` повышает надежность и устойчивость доменной системы к отказам и обеспечивает более быстрое разрешение доменных имен для пользователей.
   
   ![[Pasted image 20231114223603.png]]
  
7.  Мы получили `ip-адрес` сайта и теперь можем обратиться к нему для проверки на то что сайт `не упал`, и если так, то `скачиваем сайт` 
   
   ![[Pasted image 20231114223913.png]]
   
   8. `DNS Resolver` `сохраняет` в `кеш` найденный `сайт`, чтобы не проходить всю эту цепочку вновь. И возвращает найденный адрес сайта в браузер, чтобы тот все загрузил.

### _Handshake. Установка соединения_

`TLS Handshake`(`переговоры TLS`) - это процесс установления `безопасного соединения` между `клиентом` и `сервером`, используя протокол `TLS` (`Transport Layer Security`). 
Этот процесс происходит перед началом фактического обмена данными между клиентом и сервером.

Вот основные шаги, которые происходят в процессе `TLS Handshake`:

1. Приветствие (`Hello`): Клиент и сервер обмениваются своими `версиями TLS` и `поддерживаемыми алгоритмами шифрования`.
2. Защита (`Security`): На основе доступных `алгоритмов`, сервер `запускает` дорогостоящий метод `ассиметричного шифрования`, для создания `публичного ключа`. 
3. Аутентификация (`Authentication`): `Сервер` может отправить цифровой `сертификат` для подтверждения своей подлинности. Клиент может проверить валидность сертификата и убедиться, что сервер является `доверенным`.
4. Обмен ключами (`Key Exchange`): Клиент получает от сервера `публичный ключ` и генерирует на основе него свой `Pre-master Key` и `шифрует` им `сообщение`.
   - `Публичный ключ` приходит к `клиенту` от сервера вместе с сертификатом. Он позволяет `зашифровать` передаваемые `данные` от клиента к серверу.
   - `Приватный ключ` находится только `у сервера`. Он позволяет `расшифровать` зашифрованную информацию от клиента.
   - `Сертификат` подтверждает `подлинность` публичного  ключа, то что он принадлежит серверу, а не мошеннику.
5. Завершение (`Finish`): Клиент и сервер обмениваются сообщениями, подтверждающими успешное завершение процесса `TLS Handshake`. Далее уже используется `симметричное шифрование`(более экономное). После этого они готовы к безопасному обмену данными.
 
![[Pasted image 20231114232402.png]]

- `Симметричное шифрование` - Для шифровки и расшифровки используется 1 и тот же ключ. Ими опасно делиться, тк любая копия ключа скомпрометирует данные.
- `Асимметричное шифрование` - В нем используется 2 ключа: `публичный` и `приватный`
  Даем `публичный` и через него происходит `шифрование`. А `расшифровывание` только через `приватный`

### _Получаем разметку. WebServer + NGINX_

`NGINX` - Веб-сервер выполняющий `балансировку` и `распределение` трафика/нагрузки между нашими несколькими серверами.

![[Pasted image 20231114232741.png]]

Так же с помощью него мы можем `разделить` и `изолировать` части нашего сайта. 
Тогда при падении одной части, другая останется.

![[Pasted image 20231114232952.png]]

### _Page Rendering_

После `получения данных` сайта, `браузер` проходится по тегам `link` которые содержат в себе `стили`, так он определяет модель `CSSOM` - `стили` которые нужно `отрисовать`.

- `DOM` - предоставляет браузеру `структуру` того, что нужно отобразить.
- `CSSOM` - предоставляет `структуру`, то как нужно отобразить. 
  ![[Pasted image 20231114234254.png]]
- `Render Tree`(`дерево отрисовки`) собирает в себе `DOM` + `CSSOM`, позволяя понять браузеру что рисовать и как рисовать. В нем отображается `только то что должно быть отрисовано`. Следовательно, все `скрытые` элементы туда `не попадают`, как и теги на подобии `<script>` 

![[Pasted image 20231114233319.png]]

- `Layout Operation` - операция `расстановки`. Определяет что будет находиться в каждом пикселе. 
   На входе мы имеем `размеры элементов`, размер нашего `экрана`. Пропустив `Layout Operation` через `графический движок рендера`(например `Render 3`), на выходе мы получим размеры конечной картинки.
- `Paint Operation` - `определяем` какой `цвет` будет в каждом конкретном пикселе.
- `Coposing Operation` - после того как мы узнали что будет в каждом пикселе и какого он будет цвета, запускаем `операцию отрисовки` с помощью графического процессора.
  Эта операция идет в несколько потоков для получения картинки как можно быстрее.

![[1699995728.656827.mp4]]
