
Как мы выяснили из не рекомендуемой возможности замены `методов` и `кодов-статуса`- семантика важна. [[HTTP]] 
Поэтому хотелось бы иметь `структурированный набор правил`, `архитектурный` стиль, который будет `задавать хороший тон`. 

- `REST API` - **_Архитектурный стиль_**, набор правил который описывает то, как наиболее эффективно использовать `HTTP` и строить свое `API`. Строить так, чтобы `API` было удобно пользоваться, чтобы оно выдерживала нагрузки, легко масштабировалось и тд. 
   Архитектура `REST API` сообщает нам о том, **_как наиболее эффективно общаться_** `клиенту` и `серверу` по `HTTP`.

![[Pasted image 20231115203956.png]]

- `API`(`App Prog Interface`) - программный интерфейс. 
`Интерфейс` это `методы`(`endpoint-ы`), которые описаны в `документации`. 
При обращении к серверу предоставляющему `API`, мы получим данные(`тело ответа`).

![[Pasted image 20231115202907.png]]

### _Концепция REST API_

### _1. Клиент-серверная архитектура_

`REST API` основан на принципе разделения `клиента` и `сервера`. 
- `API` представлено в виде `Cервера`.
- А `Потребителем` могут выступать как десктопные, мобильные, браузерные приложения, так и другие сервера. 

Что это значит? 
**Разделение на клиента и сервер**: Взаимодействие `клиента` и `сервера` осуществляется в виде `запросов и ответов`. 
- `Клиент` отвечает за `визуализацию` данных и `взаимодействие` с пользователем.
- `Сервер` отвечает за `хранение` данных и `выполнение` бизнес-логики.

![[Pasted image 20231115215404.png]]

### _2. Многоуровневость системы_

`Клиент` может взаимодействовать `со слоями сервера` без необходимости знать о внутреннем устройстве каждого слоя. 
С точки зрения` клиента система цельна`, хоть и внутри она может иметь `множество слоев` с балансированием по другим серверам, распределением и тд.

![[Pasted image 20231115215819.png]]

### _3. Отсутствие состояния (`Statelessness`)_

Это означает, что **_сервер не хранит информацию о состоянии клиента_** между запросами. 
При `каждом` следующем `запросе`, сервер и клиент общаются как в первый раз. 
Вместо этого, все необходимые `данные` для обработки запроса `передаются в самом запросе`.

И для того `чтобы сервер идентифицировал клиента`, и мог понять что ему нужно сделать, **_клиент должен заново отправлять всю необходимую полную информацию_**, для того чтобы сервер мог обработать запрос и выполнить его.

И тк `cookie` находятся на стороне клиента, а `не хранятся` на `сервере` в виде `состояния клиента`, то их использование вписывается в концепцию `statelessness`.

![[Pasted image 20231115220618.png]]
![[Pasted image 20231115220713.png]]

Беcстатусное взаимодействие снижает нагрузку на сервер, экономит память и повышает производительность.

### _4. Единообразный унифицированный интерфейс_

1. Над любыми `сущностями` (например `товарами`) мы можем выполнять `CRUD-операции`:
   - `Create` - Добавить новый товар (`POST`)
   - `Read` - получить все товары (`GET`)
   - `Update` - обновить информацию о товаре (`PUT` - полностью, `PATCH` - частично)
   - `Delete` - удалить товар (`DELETE`)

![[Pasted image 20231115221449.png]]

Поэтому, для каждой `CRUD-операции`, мы используем `семантически правильный метод`:

![[Pasted image 20231115222324.png]]

2. Для каждой `сущности`(`товара`) существует определенный `patch`(`путь`) `URL` по которому мы с ним взаимодействуем. Например `/products`, важно указывать названия для `endpoint-ов` во `множественном числе`

### _5. Кеширование_

Кеширование может производиться:
- Средствами `HTTP`, за счет проставления определенных `заголовков`, которые будут храниться `на стороне клиента`(например, `в браузере`).
- Так и `сторонними` средствами реализованными `на сервере`.

-> Пример кеширования: 
Клиент запрашивает список товаров, и сервер возвращает `список товаров` с `заголовком` `Cache-Control`, указывающим, что ответ можно `кэшировать на 1 час`. При последующих запросах на получение списка товаров, `клиент` может `использовать кэшированную версию`, если она все еще действительна.

![[Pasted image 20231115225341.png]]

-> Пример, почему `PUT` и `DELETE` не стоит кэшировать:
`PUT` и `DELETE` запросы могут вносить `изменения` в `ресурс` или даже `удалить` его. Кэширование таких запросов может привести к тому, что `клиент` будет получать устаревшие или некорректные данные, так как `кэшированная версия ресурса может не отражать последние изменения`.

### _Идемпотентность методов_

![[idempotency]]

### _Ресурс_

**Ресурс** представляет собой конкретный `объект` или `услугу`, с которым взаимодействует клиентское приложение. Ресурс может быть представлен в виде `URL`(`путь до ресурса`)
Это какой-либо `объект` на стороне сервера, над которым можно `совершать` операции `CRUD`
(`Create, Read, Update, Delete`).

-> Example: If you are creating a `RESTful` task management app, the resources can be `tasks`, task `lists`, `users`, etc.


Например, `ресурсом` может быть:
- `HTML` или `txt-файл`, `файл` данных, `изображение` или `видео`, `файл` исполняемого `кода`.
- `/users` - `ресурс`, представляющий `коллекцию пользователей` в системе. Каждый пользователь может иметь свои собственные свойства, такие как имя, электронная почта, пароль и т.д.

### _Формат при обмене данными_

Чаще всего применяют `JSON`, но так же `XML` особенно в финтехе и банковской сфере.

![[Pasted image 20231115225910.png]]

### _Версионирование_

Все `правки` которые вносятся, должны быть `обратносовместимы`.  Поэтому нужно менять именно версию.

![[Pasted image 20231115230240.png]]

### _Написание Документации_

- `Open API` - `Спецификация` которая помогает нам вручную задокументировать наше `API`
- `Swager` - `Набор инструментов` для документации и визуализации нашего `REST API`, использует спецификацию `Open API`.

![[Pasted image 20231115230639.png]]

### _REST и RESTful_

`REST` — `архитектурный стиль`, а `RESTful` это `сервис` который `следует` этому `стилю`. 
Например, если у вас на сервере REST API, а на клиенте вы делаете запросы к этому API, то у вас RESTful приложение/сайт.

### _Пример REST API_

В качества примера возьмем стандартное API для списка пользователей. Мы запрашиваем список пользователей, получаем информацию о пользователе, добавляем нового пользователя, изменяем информацию и удаляем пользователя. Если у нас на сервере REST API, то нам понадобятся следующие запросы:

1. **GET** `/api/users` — получить список пользователей
2. **GET** `/api/users/7` — получить информацию о пользователе с `ID=7`
3. **POST** `/api/users` — добавить нового пользователя
4. **PUT** `/api/users/7` — изменить информацию о пользователе с `ID=7`
5. **DELETE** `/api/users/7` — удалить пользователя с `ID=7`