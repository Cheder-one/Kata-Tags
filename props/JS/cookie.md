`Cookies` — небольшие `фрагменты данных` типа `string`, которые `сервер` отправляет `клиенту` и хранит у него. 
Браузер сохраняет куки у себя, а при следующем посещении веб-страницы отправляет обратно. Благодаря такому обмену данными, сервер сможет узнать своего «старого» посетителя. Одно `куки` вмещает до `4kb` данных, `разрешается` не более `20` куки на сайт (зависит от браузера).

![[Pasted image 20231120192918.png]]

Когда `сервер` хочет `записать куки` в браузер пользователя, он `отсылает` специальный `заголовок` ответа с названием `Set-Cookie`. 

```
HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: sessionId=123456789; Expires=Wed, 21 Oct 2022 07:28:00 GMT; Path=/
```

![[Pasted image 20231120195937.png]]

Хорошая аналогия — это как получить номерок в гардеробе и потом вернуть его, чтобы понять какая куртка ваша. 
Как и в случае с номерком в гардеробе, сам по себе кукис не представляет ценности и не может быть использован независимо от сервера. Он служит только для идентификации пользователя или для хранения определенных данных для сервера.

## _Чтение из document.cookie_

```
console.log(document.cookie)
```

Значение `document.cookie` состоит из пар `ключ=значение`, разделённых `;`. Каждая пара представляет собой отдельное куки.

Чтобы найти определённое куки, достаточно разбить строку из `document.cookie` по `;`
и затем `найти нужный ключ`. Для этого мы можем использовать как `регулярные выражения`, так и `функции для обработки массивов`.

### _Запись в document.cookie_

Мы можем писать в `document.cookie`. Но это не просто свойство данных, а [аксессор](https://learn.javascript.ru/property-accessors)[[obj_getters & setetters]]. Присваивание к нему обрабатывается особым образом.

**Запись в `document.cookie` обновит только упомянутые в ней куки, но при этом не затронет все остальные.**

-> Установка куки с именем `user` и значением `John`:
``` 
document.cookie = "user=John"; /=/ Обновляем только куки с именем 'user'
console.log(document.cookie); /=/ Показываем все куки
```

### _Особенности cookie_

Технически, и `имя` и `значение` `куки` могут состоять из `любых символов`, но для `правильного` `форматирования` следует использовать встроенную функцию `encodeURIComponent`:

``` 
/=/ Специальные символы (пробелы), требуется кодирование
let name = "my name";
let value = "John Smith"

/=/ Кодирует в my%20name=John%20Smith
document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);

alert(document.cookie); /=/ ...; my%20name=John%20Smith
```

![[Pasted image 20231120205620.png]]

## _Параметры в cookie_

```
Set-Cookie: имя=значение; expires=дата; domain=домен; path=путь; secure; httponly
```

### _domain_

- **`domain=site.com`** - Определяет `домен`, где `доступен` файл `куки`. Однако на практике мы `не можем` указать `левый домен`, можем лишь `поддомен`.

По умолчанию куки `доступны` лишь тому `домену`, `который` его `установил`.
Так же, `по умолчанию` файл `куки` также `не передаётся поддомену`, например `forum.site.com`

**Нет никакого способа разрешить доступ к файлам куки из другого домена 2-го уровня, поэтому `other.com` никогда не получит куки, установленный по адресу `site.com`.**

```
/=/ Eсли мы установим файл куки на веб-сайте site.com...
document.cookie = "user=John"

/=/ Мы НЕ увидим его на поддомене: forum.site.com
console.log(document.cookie); /=/ Нет user
```

Но это можно изменить. Если мы хотим `разрешить поддоменам` типа `forum.site.com` получать `куки`, установленные на `site.com`, это возможно.

Для этого, при установке файла куки в `site.com`, мы должны явно установить параметр `domain` для корневого домена: `domain=site.com`. После этого `все поддомены` `увидят` такой файл `cookie`.

``` 
/=/ Находясь на странице site.com
/=/ Сделаем куки доступным для всех поддоменов *.site.com:
document.cookie = "user=John; domain=site.com"

/=/ На forum.site.com
console.log(document.cookie); /=/ Есть куки user=John
```

### _path_

- **`path=/mypath`** - Определяет `для какой` конкретно `части сайта` предназначен `куки`. 
  Путь должен быть абсолютным. По умолчанию используется текущий путь.

Например, если `куки` установлено с `path=/admin`, то оно будет доступно на страницах `/admin` и `/admin/something`, но не на страницах `/home` или `/adminpage`. 

Как правило, указывают в качестве пути корень `path=/`, чтобы `куки` было `доступно` на `всех страницах` сайта.

### _expires, max-age_

Если `куки не имеют` ни одного из этих `параметров`, то они удалятся при закрытии браузера. Такие куки называются `сессионными`(`session cookies`).

Чтобы помочь куки «пережить» закрытие браузера, мы можем установить значение опций `expires` или `max-age`.

```
expires=Tue, 19 Jan 2038 03:14:07 GMT
```

Дата должна быть точно в этом формате, во временной зоне `GMT`. Мы можем использовать `date.toUTCString`, чтобы получить правильную дату. Например, мы можем установить срок действия куки на 1 день.

``` 
/=/ +1 день от текущей даты
let date = new Date(Date.now() + 86400e3);
date = date.toUTCString();
document.cookie = "user=John; expires=" + date;
```

``` 
/=/ Куки будет удалено через 1 час
document.cookie = "user=John; max-age=3600";

/=/ Удалим куки (срок действия истекает прямо сейчас)
document.cookie = "user=John; max-age=0";
```

### _secure_

- **`secure`** - `Куки` разрешено `передавать` только по `HTTPS`-протоколу.

**По умолчанию куки, установленные сайтом `http://site.com`, 
также будут доступны на сайте `https://site.com` и наоборот.**

То есть, куки, по умолчанию, опираются на доменное имя, они не обращают внимания на протоколы. 
Таким образом, если в `куки` хранится `конфиденциальная` информация, которую не следует передавать по незашифрованному протоколу HTTP, то нужно установить флаг `secure`.

``` 
/=/ Предполагается, что сейчас мы на "https://"
/=/ Установим опцию secure для куки (куки доступно только через HTTPS)
document.cookie = "user=John; secure";
```

### _samesite_

Настройка безопасности, применяется для защиты от так называемой `XSRF-атаки` (межсайтовая подделка запроса).

-> Например, просматривая веб-страницу в другом окне, вы случайно переходите на сайт `evil.com`, который автоматически отправляет форму `<form action="https://bank.com/pay">` на сайт `bank.com` с заполненными полями, которые инициируют транзакцию на счёт хакера.

Браузер посылает куки при каждом посещении `bank.com`, даже если форма была отправлена с `evil.com`. Таким образом, банк узнает вас и выполнит платёж.

![[Pasted image 20231120232655.png]]

Такая атака называется межсайтовая подделка запроса (или Cross-Site Request Forgery, XSRF).

### _HttpOnly cookie_

Определяет, `может` ли `JavaScript` `обращаться` к данному `куки`.

Веб-сервер использует заголовок `Set-Cookie` для установки куки. И он может установить настройку `httpOnly`.

Эта настройка `запрещает` любой `доступ` к `куки` из `JavaScript`. Мы не можем видеть такое куки или манипулировать им с помощью `document.cookie`. Это дополнительный уровень безопасности от `XSS-атак`

## _Функции для работы с куки_

### _getCookie(name)_

Функция `getCookie(name)` возвращает куки с указанным `name`:

``` 
/=/ Возвращает куки с указанным name,
/=/ Или undefined, если ничего не найдено
function getCookie(name) {
  let matches = document.cookie.match(new RegExp(
    "(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"
  ));
  return matches ? decodeURIComponent(matches[1]) : undefined;
}
```

Здесь `new RegExp` генерируется динамически, чтобы находить `; name=<value>`.
Обратите внимание, значение куки кодируется, поэтому `getCookie` использует встроенную функцию `decodeURIComponent` для декодирования.

### _setCookie(name, value, options)_

Устанавливает куки с именем `name` и значением `value`, с настройкой `path=/` по умолчанию (можно изменить, чтобы добавить другие значения по умолчанию):

``` 
function setCookie(name, value, options = {}) {
  options = {
    path: '/',
    /=/ При необходимости добавьте другие значения по умолчанию
    ...options
  };

  if (options.expires instanceof Date) {
    options.expires = options.expires.toUTCString();
  }

  let updatedCookie = encodeURIComponent(name) + "=" + encodeURIComponent(value);

  for (let optionKey in options) {
    updatedCookie += "; " + optionKey;
    let optionValue = options[optionKey];
    if (optionValue !== true) {
      updatedCookie += "=" + optionValue;
    }
  }

  document.cookie = updatedCookie;
}

/=/ Пример использования:
setCookie('user', 'John', {secure: true, 'max-age': 3600});
```

### _deleteCookie(name)_

``` 
function deleteCookie(name) {
  setCookie(name, "", {
    'max-age': -1
  })
}
```

![[Pasted image 20231120233433.png]]

## _Типы cookie_

Выполним запрос для `получения` только `заголовков`. 
Для этого добавим к запуску _`curl`_ флаг _`--head`_

```
set-cookie: _hexlet_session2=AiUPd6RFbcrnoGnZSLAYSBzdJqxsQ4sTc%2BW0xXuOKzlenyv5GwkkbpdkD6IVDybDlD8vQcOcgGax98%2FmzIBJrz9f%2BDIJxWRpknZsRSfBXuC9yRfndovBUG6w4fTql4qp7zPozd2veFDLOU4koPVYiUQxgBLM6NkyYg%2Bhs%2BQe%2FSZezleVgMBVD%2FFC070DjV7t2eN01o26kcbd0pQsf9k1LE4JN0aDzSxu8elxLyAWkIJ5l3m%2BcI%2BpgOxk87Uwh9WdTHVuDaraiRaVJz1aZq5hr%2FgzaZiK%2Bgi6ChX60nhha1an610b1v3EE7xgkEM332uFPU0w675fHEr4APTdPDVtJRa3--qQi0cqcljC8i4klD--fXTErw9bhX7%2Fd1xfPE4Gww%3D%3D; domain=.hexlet.io; path=/; expires=Sun, 16 Aug 2020 03:38:11 GMT; secure; HttpOnly; SameSite=Lax

set-cookie: GCLB=CLTE8bzdlaS6Zg; path=/; HttpOnly; expires=Thu, 16-Jul-2020 03:39:50 GMT
```

В ответе, будет находиться два `заголовка`, которые занимаются установкой `cookie` — _`set-cookie`_. Каждая `cookie` посылается в `отдельном заголовке`. 

### _Сессионные куки_

В нашем запросе `сессионные куки не устанавливаются`, так как мы видим `дополнительные параметры` в заголовке _`set-cookie`_. Сохраняются в оперативной памяти браузера.

### _Постоянные куки_

В нашем случае устанавливаются `постоянные куки`. Они сохраняются на `жестком диске`. Такие куки отличаются от сессионных тем, что можно управлять длиной их жизни при помощи параметра _`expires`_:

```
expires=Thu, 16-Jul-2020 03:39:50 GMT;
```

В параметре _`expires`_ указывается `дата удаления куки`, после которой она не будет отсылаться на сервер. 
Стоит сказать, что есть еще один параметр, который используется для тех же целей — _MAX-AGE_. В его значении указывается количество секунд, по истечении которых кука будет удалена:

```
MAX-AGE=2592000; /=/ часть браузеров не поддерживают _MAX-AGE_
```

## _Параметры domain и path_

Параметры _`domain`_ и _`path`_ задают **область видимости куки** — это URL, на которые кука может отправляться. Если они не заданы, то по умолчанию кука будет пересылаться на сервер только для текущего пути и домена. В нашем примере в _path_ указан корень сайта, то есть кука будет отправляться для всех страниц:

```
domain=.hexlet.io; path=/;
```

Если установлен _`domain=.hexlet.io`_, то кука будет `работать` не только для `всех страниц сайта`, но и `для всех поддоменов` — при этом наличие точки перед именем домена не имеет значения.
Если мы совсем `не установим` параметр _`domain`_, то `кука` для `поддоменов работать не будет`, хотя по умолчанию значение домена будет _hexlet.io_.

## _Переустановка куки. Уникальность_

`Уникальность куки` определяется `тремя` параметрами:
- _`key`_(имя `куки`)
- _`domain`_
- _`path`_

Это значит, что `если` какую-то `куку нужно переустановить`, то при следующем запросе в _`set-cookie`_ эти `3 параметра должны совпадать`. Если хотя бы один из них отличается, то будет установлена новая кука.

## _Удаление куки_

Заголовка для удаления куки не существует. Чтобы удалить ее, нужно `установить нулевой или отрицательный` _`MAX-AGE`_, либо задать _`expires`_ `в прошлом`, тогда кука будет немедленно удалена.

## _Отправка cookie на сервер_

При обновлении страницы браузера, происходит отправка следующего заголовка:

![[Pasted image 20231120202749.png]]

Все `куки` отправляются `одним заголовком` в формате _`key=value; key=value`_ 
`без дополнительных параметров`.

## _Аутентификация vs Авторизация_

![[Pasted image 20231120194151.png]]

`Аутентификация` это например простая проверка совпадения почты и пароля при входе на сайт. Сценарий, обрабатывающий форму, лишь проверяет, что такой пользователь существует, и его пароль совпадает.

`Авторизация` включается в работу, когда пользователь выполняет какое-нибудь действие. Например, удаляет товар из своей корзины. Во время этого действия сценарий должен проверить принадлежность товара к корзине этого пользователя. Без такой проверки пользователь мог бы удалить товар из чужой корзины.

### _Заголовки авторизации_

**Заголовок авторизации** - это `часть` HTTP-`запроса` или `ответа`, содержащая информацию для `аутентификации` пользователя. Заголовок `Authorization` используется для передачи `учетных данных` от `клиента` к `серверу`.

```
Authorization: Bearer <токен доступа>
Authorization: тип_авторизации данные_авторизации
```

- `тип_авторизации` может быть, например, "`Basic`" или "`Bearer`", в зависимости от используемого `метода аутентификации`.
- `данные_авторизации` представляют собой `закодированные` учетные данные.

### _Сессии на куках_

Сессии на куках обычно реализуются путем хранения уникального `идентификатора сеанса` в `cookies` клиента. При каждом запросе клиента, сервер `проверяет` этот `идентификатор` и `восстанавливает данные сеанса`.

### _Пример ответа сервера_

Предположим, что `сервер` успешно `аутентифицировал пользователя` и `создал сессию`. Он `отправит` ответ с `заголовком Set-Cookie`, чтобы `установить` куки с `идентификатором сеанса`.
___
```
GET /api/user/1 HTTP/1.1
Host: example.com
Set-Cookie: имя_куки=значение; expires=дата_истечения; path=путь; domain=домен;
```

- `имя_куки` - имя куки.
- `значение` - значение куки.
- `expires` - дата истечения срока действия куки.
- `path` - путь части сайта, для которого куки действительны.
- `domain` - домен/поддомен, для которого куки действительны.
___

```
HTTP/1.1 200 OK
Content-Type: text/html
Set-Cookie: session_id=abc123; expires=Sat, 22 Nov 2023 12:00:00 GMT; path=/; HttpOnly
```

- `session_id=abc123` - это уникальный `идентификатор` сеанса.
- `expires` - указывает дату истечения `срока` действия куки.
- `path=/` - определяет, для каких `путей` URL сайта куки действительны.
- `HttpOnly` - `предотвращает` доступ к куки через `JavaScript`, улучшая безопасность.

### _Пример запроса клиента_

При следующем `запросе клиента` к `серверу`, он включит `куки в заголовке запроса`.

```
GET /secure-page HTTP/1.1
Host: example.com
Cookie: session_id=abc123
```

- `session_id=abc123` - это отправленный клиентом идентификатор сеанса.

Таким образом, `сервер` `использует` информацию в куках (в данном случае, `идентификатор сеанса`) для `связывания запросов` от `клиента` с конкретной `сессией на сервере`, тем самым обеспечивая управление состоянием сеанса.

## _Local Storage vs. Session Storage vs. Cookie_

### Local Storage ([[localStorage]])  

- Хранит данные бессрочно.
- Очищается только с помощью JavaScript или очистки кэша браузера.
- Хранит данные объёмом до 5 МБ, это самый большой объём из трёх вариантов хранилища.
- Не поддерживается старыми браузерами, например, IE 7 и ниже.
- Работает по правилу ограничения домена (same origin policy). То есть сохранённые данные доступны только для одного источника.

### Session Storage (сессионное хранилище)

- Хранит данные, пока продолжается текущая сессия. Когда пользователь закрывает браузер, данные становятся недоступными.
- Используется контекст браузера верхнего уровня, поэтому каждая вкладка браузера хранит уникальные данные.
- Объём данных больше чем в Cookie.
- Не поддерживается старыми браузерами, например, IE 7 и ниже.

### Cookie

- Хранит данные, которые можно передавать на сервер через заголовки.
- Локальное и сессионное хранилище доступны только на клиентской стороне.
- Срок хранения устанавливается при создании cookie.
- Объём данных не превышает 4 Кбайт.
- Cookie могут быть защищёнными, в этом случае их содержимое нельзя получить на стороне клиента. Это важно для аутентификации при хранении пользовательских токенов.