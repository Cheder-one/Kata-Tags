Замыкание - это функция, которая помнит переменные из внешней области видимости и сохраняет доступ к ним даже когда родительская функция завершена.

В JavaScript, все функции изначально являются замыканиями.
Тк они автоматически запоминают, где были созданы, с помощью скрытого свойства `[[Environment]]`, и все они могут получить доступ к внешним переменным.

```
function outer() {
    const x = 5; /=/ Локальная переменная

    return function inner() {
        console.log(x); /=/ Замыкание имеет доступ к x
    };
}

const closureFunc = outer(); /=/ [λ: inner]
closureFunc(); /=/ 5
```

-> Example: Подсчет суммы элементов в массиве

```
const getArrSum = ([...arr], acc = 0) => {
	acc += arr.pop();

	if (arr.length !== 0) {
		acc = getArrSum(arr, acc); /=/ Важно не пропустить `acc = ...`
	}

	return acc;
};

const arr = [1, 2, 3]; /=/ [ 1, 2, 3 ]
getArrSum(arr);        /=/ 3
console.log(arr);      /=/ [ 1, 2, 3 ]
```

-> Example: Подсчет строк во вложенных объектах и массивах

```
function getStringCount(input) {
  let count = 0;

  if (Array.isArray(input)) {
    for (let i = 0; i < input.length; i++) {
      count += getStringCount(input[i]);
    }
  } else if (typeof input === "object" && input !== null) {
    for (let key in input) {
      count += getStringCount(input[key]);
    }
  } else if (typeof input === "string") {
    count++;
  }

  return count;
}

console.log(
  getStringCount({
    first: "1",
    second: "2",
    third: false,
    fourth: { a: ["anytime", "2", 3, 4] },
    fifth: null,
  })
); // 4

console.log(getStringCount(["1", "2", ["3"]])); // 3
```

-> Example: Рекурсивные обходы

1. Либо это «простой» отдел с _массивом_ – тогда мы сможем суммировать зарплаты в простом цикле.
2. Или это _объект_ с `N` подотделами – тогда мы можем сделать `N` рекурсивных вызовов, чтобы получить сумму для каждого из подотделов, и объединить результаты.

- Случай (1), когда мы получили массив, является базой рекурсии, тривиальным случаем.
- Случай (2), при получении объекта, является шагом рекурсии. Сложная задача разделяется на подзадачи для подотделов. Они могут, в свою очередь, снова разделиться на подотделы, но рано или поздно это разделение закончится, и решение сведётся к случаю (1).

---
### _`[[Environment]]` - среда_

Когда функция создается, она сохраняет ссылку на свое окружение в свойстве `[[Environment]]`.
Это позволяет функции обращаться к переменным, определенным внутри этого окружения, даже после того как вызов функции завершился.

### _`Null` - первичная родительская ссылка_

- Самому первому родительскому элементу не на кого ссылаться из элементов, поэтому он ссылается на `null`

### _Замыкания и асинхронность_

Некоторые функции выполняются `асинхронно`, поэтому в момент выполнения кода значение переменной может уже измениться.
Чтобы избавиться от этой проблемы, нужно создать отдельную область видимости. Так все переменные будут под контролем и замыкания не позволят потерять необходимые значения.

---

```
var photos = [
  'gallery/laptop-large.jpg',
  'gallery/microphone-large.jpg',
  'gallery/keyboard-large.jpg',
  'gallery/signboard-large.jpg',
  'gallery/tree-large.jpg'
];

var thumbnails = document.querySelectorAll('.gallery__photo-preview');
var fullPhoto = document.querySelector('.full-photo');

/=/ Не сработает:
for (var i = 0; i < thumbnails.length; i++) {
  thumbnails[i].addEventListener('click', function () {
    fullPhoto.src = photos[i];
  });
}
```

Обработчики, которые мы создали, используют значение счётчика `i`. Сложность в том, что обработчики срабатывают не сразу, а в момент наступления события. К тому моменту, когда первое событие клика выполняется, **цикл полностью отработал**, значение счётчика стало максимальным — `5`, и функция-обработчик берёт именно это значение. **Цикл не создаёт отдельную область видимости**, это ведь не функция. **Поэтому значение `i` находится в глобальной области** и каждый обработчик обращается к этому значению `5`.
А у нас нет миниатюры с таким индексом и элемента в массиве `photos`, поэтому никакая картинка и не подставляется.

Это можно исправить через Замыкания.
У каждого обработчика будет собственное замыкание, поэтому значения в обработчиках не будут повторяться, как это было раньше.

```
const addThumbnailClickHandler = (thumbnail, photo) => {
  thumbnail.addEventListener("click", function () {
    fullPhoto.src = photo;
  });
};

for (var i = 0; i < thumbnails.length; i++) {
  addThumbnailClickHandler(thumbnails[i], photos[i]);
}
```
