### _Отличие Замыкания, Колбэка и Рекурсии_

### _Сlosure_

Замыкание - это функция, которая может помнит переменные из внешней области видимости и может их использовать.

В JavaScript, все функции изначально являются замыканиями.
Тк они автоматически запоминают, где были созданы, с помощью скрытого свойства `[[Environment]]`, и все они могут получить доступ к внешним переменным.

```
function outer() {
    const x = 5; /=/ Локальная переменная

    return function inner() {
        console.log(x); /=/ Замыкание имеет доступ к x
    };
}

const closureFunc = outer(); 
/=/ closureFunc - Это функция `inner`
closureFunc(); /=/ 5
```

### _`[[Environment]]` - среда_

Когда функция создается, она сохраняет ссылку на свое окружение в свойстве `[[Environment]]`.
Это позволяет функции обращаться к переменным, определенным внутри этого окружения, даже после того как вызов функции завершился.

### *Замыкания и асинхронность*

Некоторые функции выполняются `асинхронно`, поэтому в момент выполнения кода значение переменной может уже измениться. 
Чтобы избавиться от этой проблемы, нужно создать отдельную область видимости. Так все переменные будут под контролем и замыкания не позволят потерять необходимые значения.

---

```
var photos = [
  'gallery/laptop-large.jpg',
  'gallery/microphone-large.jpg',
  'gallery/keyboard-large.jpg',
  'gallery/signboard-large.jpg',
  'gallery/tree-large.jpg'
];

var thumbnails = document.querySelectorAll('.gallery__photo-preview');
var fullPhoto = document.querySelector('.full-photo');

/=/ Не сработает:
for (var i = 0; i < thumbnails.length; i++) {
  thumbnails[i].addEventListener('click', function () {
    fullPhoto.src = photos[i];
  });
}
```

Обработчики, которые мы создали, используют значение счётчика `i`. Сложность в том, что обработчики срабатывают не сразу, а в момент наступления события. К тому моменту, когда первое событие клика выполняется, **цикл полностью отработал**, значение счётчика стало максимальным — `5`, и функция-обработчик берёт именно это значение. **Цикл не создаёт отдельную область видимости**, это ведь не функция. **Поэтому значение `i` находится в глобальной области** и каждый обработчик обращается к этому значению `5`. 
А у нас нет миниатюры с таким индексом и элемента в массиве `photos`, поэтому никакая картинка и не подставляется.

Это можно исправить через Замыкания.
У каждого обработчика будет собственное замыкание, поэтому значения в обработчиках не будут повторяться, как это было раньше.

```
const addThumbnailClickHandler = (thumbnail, photo) => {
  thumbnail.addEventListener("click", function () {
    fullPhoto.src = photo;
  });
};

for (var i = 0; i < thumbnails.length; i++) {
  addThumbnailClickHandler(thumbnails[i], photos[i]);
}
```

---
### _Callback_

Функция которая передается в качестве аргумента другой функции и вызывается ею.

```
 function add(a, b, callback) {
     const result = a + b; /=/ Вычисляем результат
     callback(result); /=/ Вызываем колбэк с результатом
 }

 function print(x) {
     console.log(x); /=/ Выводим x
 }

 add(2, 3, print); /=/ 5
 /=/ Передаем print в качестве колбэка для add
```

### _Recursion_

Функция которая вызывает сама себя с новыми аргументами.

```
function factorial(n) {
    if (n === 0) {
            return 1; /=/ Базовый случай
    } else {
        return n * factorial(n - 1); 
        /=/ Рекурсивный вызов с меньшим аргументом
    }
}

console.log(factorial(5)); /=/ 120
```
