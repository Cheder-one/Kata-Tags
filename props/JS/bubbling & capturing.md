### _Всплытие_

При `клике` на элемент, сигнал о нажатии распространяется от `внутреннего` вложенного элемента к самому внешнему - `корневому` элементу. 
Тем самым, `всплытие` проходится `вверх` по иерархии и `триггерит` `слушатели` событий родительских элементов. Это позволяет отреагировать на событие их дочерних элементов.

![[Pasted image 20231103212708.png]]

### _e.stopPropagation()_

По умолчанию, в JavaScript `все` события `всплывают` (кроме `focus`)

Остановить передачу события выше:
 - `event.stopPropagation()` - препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.
 - `event.stopImmediatePropagation()` - полностью предотвращает всплытие, и останавливает обработку событий на текущем элементе.

### _Погружение {capture: true}_

Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент `capture 

``` 
document.addEventListener('click', function(event) {
	// 
}, {capture: true});


element.addEventListener('click', myFunction, true);
/=/ Или просто "true", как сокращение для {capture: true}
```

Стандарт `DOM Events` описывает 3 фазы прохода события:
1. Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
2. Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
3. Фаза всплытия (bubbling stage) – событие начинает всплывать.

![[Pasted image 20231103215414.png]]

### _e.stopPropagation() на Погружении_

- Если в случае со `всплытием` мы `блокировали` `всплытие` к установленному обработчику на `window`, реагируя только на нажатие по `button`
- То в случае с `погружением`, `e.stopPropagation()` будет блокировать распространение события к нижним уровням. Следовательно сработает только обработчик на `window`, а продвижение сигнала к `eventListener` на `button` будет `заблокировано`. 

## _Делегирование событий_

Вместо того чтобы назначать обработчики событий на каждый отдельный элемент, вы можете назначить один обработчик событий на их `общего родителя`.

Когда `событие` происходит в элементе, оно сначала `запускает обработчики` событий для `элемента`, затем `событие всплывает` вверх и может быть  `обработано родителем` через `event.target` и так далее, пока не достигнет объекта `document`.

---
 - `event.target` - Самый глубокий элемент, который вызывает событие (по которому кликнули)
 - `event.currentTarget` - Схоже с `this`. Это тот `элемент` перед точкой на который повесили обработчик. Но в отличие от `this` сохраняет свой контекст при реализации `addEventListener` через `arrow func`.

```
button.addEventListener('click', function(event) {
  if (event.target.matches('.my-button')) {
    console.log(event.currentTarget) /=/ <button>+</button>
    console.log(this)                /=/ <button>+</button>
  }
});
```

При реализации `addEventListener` через `arrow func`, `this` будет ссылаться на то где был объявлен(написан) `слушатель`. Вероятнее всего контекст будет ссылаться на `window`.

```
button.addEventListener('click', (event) => {
  if (event.target.matches('.my-button')) {
    console.log(event.currentTarget) /=/ <button>+</button>
    console.log(this)                /=/ Window 
  }
});
```

---
![[_.matches()]]

