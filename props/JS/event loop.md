- `Event Loop` - цикл событий. Его идея заключается в том, что есть бесконечный цикл, в котором движок ожидает задачи, выполняет их и снова ожидает появление новых задач.
- `Event Loop` предоставляется средой (`браузером`, `NodeJS`), но **_не является частью JS_**.
Внутренняя реализация `Event Loop` может быть разная. 

Например: `Chrome` - `V8` и  `NodeJS` - `V8` 
Но внутренний механизм их `цикла событий` разный!

![[Pasted image 20231106135450.png]]

![[Pasted image 20231106135632.png]]
___
- `Stack` — Структура данных в виде стопки бумаг. Чтобы взять бумагу - берем ее сверху. Чтобы положить, так же кладем сверху:
Последним пришел - первым ушел (`LIFO`: `last in, first out`).
- `Queue` — Структура данных, элементы в которой действуют по принципу:
Первый пришел - первый ушел (`FIFO: first in, first out`)
---
## _Call Stack_

Отвечает за выполнение `синхронного` кода. Стопка вызовов.
`Call Stack` —  **_предоставляется движком JS_**. 

При вызове какой-то `функции` она попадает в `Call Stack`, выполняется и уходит.

![[Pasted image 20231106132201.png]]

### _Переполнение Стека_

`Call Stack` ограничен по кол-ву находимых в нем функций. При переполнении стека вызовов выстрелит ошибка: `RangeError: Maximum call stack size exceeded`

![[Pasted image 20231106133222.png]]

Решить переполнение стека можно через `цикл` или `обход дерева через стек`.

![[Pasted image 20231106133433.png]]

# _Очереди Event Loop_

Все `очереди задач` _**предоставляет Enent Loop**_

## _Macrotasks_

`Макрозадачи` включают в себя операции, которые занимают `больше времени` и требуют `больше вычислений`. Такие как:
- таймеры (`setTimeout`, `setInterval`)
- сетевые запросы (`fetch`, `XMLHttpRequest`)
- пользовательские события (`click`, `keyup`) и другие `асинхронные операции`.
___
1. Сначала, как и любая задача, `мАкротаска` попадает в `Call Stack`.
2. Затем отправляется в `Web API` где происходит ее `выполнение`.
3. Как только задача `готова`, она перемещается в очередь-ожидания в `Callback Queue`.
4. Если `Call Stack` оказался `пуст` - наш `callback` перемещается в `Call Stack`, вызывается и выполняется

### _Macrotask Queue (`Callback Q`,`Task Q` , `Event Q`)_

![[1699274459.0066094.mp4]]

### _Web API. Как `Call Stack` и `Event Loop` сообщаются_

`Web API` действует как `буферная зона ожидания` между `стеком вызовов`(`Call Stack`) и `циклом событий`(`Event Loop`).

Когда встречается `асинхронная операция`, такая как: `setTimeout` / `fetch` / `event`,
то операция передается в `Web API`(`браузерной среде`) для `фонового ожидания` и `выполнения` в ней.

Это позволяет `избежать блокировки` кода, и `продолжить` выполнение инструкций 
в `Call Stack`(`стеке вызовов`). В то время как `асинхронные операции` будут `выполняться в фоне`, ожидая своей готовности.

Как только `асинхронная операция` будет готова, `Web API` помещает соответствующую `макрозадачу`(наш `callback`) в очередь `Callback Queue`(`очередь макрозадач`).

Затем, когда `JavaScript-движок` имеет возможность (когда `стек вызовов` пустой), 
он берет первую `макрозадачу` из `Callback Queue` и перемещает ее в `Call Stack` (`стек вызовов`), где `вызывает` наш `callback` и код в нем выполняется.

## _Microtasks_

`Микрозадачи` включают в себя:
- `promise`
- `try..catch`
- метод `queueMicrotask`
- методы `MutationObserver`
---
`Микрозадачи` имеют более высокий приоритет, чем `макрозадачи`.

`Цикл событий`(`Event Loop`):
1. После каждого `завершения` текущей `задачи`:
	- Проверяет наличие задач в `Microtask Queue`, выполняет все.
2. Перед выбором следующей макрозадачи из `macrotask queue`
	- Проверяет наличие задач в `Microtask Queue`, выполняет все.

![[Pasted image 20231101210141.png]]

`Микрозадачи` столь `приоритетны` в выполнении, потому что они `выполняются` перед:
- `рендерингом`
- `анимацией`
- `другими задачами` браузера
От них зависит `плавность` обновлений `интерфейса`.

### _Microtask Queue (`Promise Q`,`Job Q` )_

Сразу после каждой `макрозадачи` движок выполняет все задачи из `Microtask Queue` перед тем, как выполнить следующую `макрозадачу` или отобразить изменения на странице, или сделать что-либо ещё.

![[Pasted image 20231101210612.png]]

![[Pasted image 20231101210248.png]]

### _Приоритет выполнения_

1. Сначала происходит выполнение всех `синхронных` задач. 
2. Если движок достиг последней строчки кода, то переходит к очереди `Microtask`
	- Если в `Microtask` что-то есть, то добавляет в `Call Stack` и выполняет. 
3. Если `Microtask` нет, то проверяет `Callback Queue`(`очередь макротасок`)
     Если `Call Stack` пуст:
	  - То из `Callback Queue` берется **_ОДНА_** `макротаска`
	  - Перемещает в `Call Stack`, `вызывается` и код внутри `выполняется`.
	  - После выполнения одной `макротаски`, выполняются все `Microtask`(если есть)

```
/=/ Makro queue  
console.log("mAcro-task start");  
  
/=/ Callback queue  
setTimeout(() => {  
  /=/ Makro queue  
  console.log("async callback 1");  
  
  /=/ Micro queue  
  Promise.resolve().then(() => {  
    console.log("mIcro-task in setTimeout");  
  });  
}, 0);  
  
/=/ Callback queue  
setTimeout(() => {  
  console.log("async callback 2");  
}, 0);  

console.log(1);

const promise = new Promise((resolve) => {  /=/ Промисы вызваются сразу...
  /=/ Makro queue  
  console.log("mAcro-task in promise"); 
  /=/ ...поэтому log выполнится при первом синхронном прохождении
  
  /=/ Micro queue  
  resolve("mIcro-task promise");  
});  

console.log(2);

/=/ Micro queue  
promise.then((result) => {  
  console.log(result);  
});  
  
/=/ Makro queue  
console.log("mAcro-task end");  
  
// mAcro-task start
// 1
// mAcro-task in promise
// 2
// mAcro-task end
// mIcro-task promise
// async callback 1
// mIcro-task in setTimeout
// async callback 2
```
