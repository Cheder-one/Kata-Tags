`bind`, `call`, `apply` - Методы для привязки к функции какого-то контекста 
(Применимы только к Функциям)

Функции это тоже объекты и у них есть методы.

### *.call() .apply() - Вызвать "как..."*

 - `call` принимает аргументы в виде отдельных значений
 - `apply` принимает аргументы в виде массива.

Метод `call()` является одним из способов явного указания объекта, который будет использоваться в качестве значения `this` внутри функции.

```
function greet(message) {
    return `${message}, ${this.name}!`;
}

const person = { name: "John" };
greet.call(person, "Welcome"); // "Welcome, John!"
```
 
Когда мы вызываем метод `call()` на функции `greet` и передаем ему объект `person` в качестве аргумента, **_это означает, что внутри функции `greet`, значение `this` будет ссылаться на объект `person`_**. 
Таким образом, `this.name` возвращает значение `"John"`, и результатом будет строка `"Hello, John!"`.

### *.bind()*

```
let bound = func.bind(context, [arg1], [arg2], ...);
```

Метод `bind` задает контекст `this`, но не вызывает функцию. 
При этом он создает и возвращает новую функцию, с заданным `this`.

-> Example 1
```
function greet() {
	return `Hello, ${this.name}!`;
}

const person = { name: 'John' };

const greetPerson = greet.bind(person);
greetPerson(); // Выведет "Hello, John!"
```

---
-> Example 2

Воспользуемся `bind`, чтобы создать функцию `double` на основе `mul()`

``` 
function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2);

alert( double(3) ); /=/ mul(2, 3) = 6
alert( double(4) ); /=/ mul(2, 4) = 8
alert( double(5) ); /=/ mul(2, 5) = 10
```

Вызов `mul.bind(null, 2)` создаёт новую функцию `double`, которая передаёт вызов `mul`, фиксируя `null` как контекст, и `2` – как первый аргумент. Следующие аргументы передаются как есть.

### _Когда использовать call(), а когда bind()?_

Методы `call()` и `bind()` оба позволяют явно установить значение `this` внутри функции, но есть некоторые отличия в их использовании.

Метод `call()` используется, когда мы хотим вызвать функцию немедленно и передать объект `this` в качестве аргумента. 
При использовании `call()`, функция вызывается сразу, и мы можем передать аргументы функции после указания объекта `this`.

```
function greet(message) {
    return `${message}, ${this.name}!`;
}

const person = { name: "John" };
greet.call(person, "Welcome"); // "Welcome, John!"
```
---
Метод `bind()`, с другой стороны, используется, когда мы хотим создать новую функцию, которая будет иметь указанное значение `this`. 
При использовании `bind()`, функция не вызывается немедленно, а вместо этого создается новая функция, которая будет иметь привязку к указанному объекту `this`.

```
function greet(message) {
    return `${message}, ${this.name}!`;
}

const person = { name: "John" };
const greetPerson = greet.bind(person);
greetPerson("Welcome"); // "Welcome, John!"
```

Одно из преимуществ метода `bind()` заключается в том, что мы можем сохранить созданную привязку и вызывать новую функцию в разных местах в коде.

