Значение `this` – это `объект` «перед точкой», который используется для вызова метода.

```
let group = {
	title: "Our Group",
	students: ["John", "Pete", "Alice"],
	
	showList() {
			this.students.forEach((student) => {
			console.log(this.title + ": " + student);
		});
	}
};

"this" 
vvvvv
group.showList();
```

`group.showList();` - это вызов метода `showList` объекта `group`. И хоть функция и вызывается глобально, но она берет контекст `this` из приставленного к ней объекта `group`.

Внутри `стрелочной функции` в цикле `forEach` контекст `this` будет унаследован из метода `showList()`, и он будет указывать на объект `group`. Тк стрелочные функции получают  `контекст` окружающей среды где были объявлены, в данном случае, метода `showList()`.

---
Ключевое слово  `this` -  дает доступ к объекту (ссылается на объект), в контексте которого выполняется текущая функция. 
Значение `this` зависит от того, где функция вызывается, и оно может указывать на разные объекты в разных ситуациях. Оно определяется в момент выполнения, а не на этапе объявления функции.

**-> Контекст объекта**
```
let user = {
  name: "John",
  age: 30,
  /=/ "this" - это "текущий объект".

  sayHi() {
    console.log(this.name);
  }
};

user.sayHi(); // John
```

**-> Глобальный контекст** 
```
console.log(this);
--------OR----------
function globalFunction() {
	console.log(this); // Внутри функции, но без привязки к объекту
}
globalFunction();
```

---

- Если `this` используется **внутри метода/функции**, оно ссылается на объект, **в контексте** которого функция была вызвана.
- Если `this` используется **не в функции**, то оно ссылается на **глобальный объект** (например, `window` в браузере или `global` в Node.js).

---
### _`this`ссылается на внешний контекст вокруг себя_

- `this` ссылается на внешний контекст вокруг себя и **работает только внутри метода**

```
const obj = {
  x: 1,
	method() {
    return ++this.x
  },
};

obj.x; // 1
obj.method(); // 2
obj.x; // 2
```

### _`this` работает только внутри метода_

- `this` не может ссылаться на сам объект вне метода объекта

```
let y = 50

const obj = {
  obj2: {
    y: 2,
    addY0: this,
    addY: ++this.y,
  },
};

obj.obj2.y; // 2
obj.obj2.addY0; // { y: NaN }
obj.obj2.addY; // NaN
```

`|>` Объяснение:
Проблема здесь связана с тем, что `this` внутри `obj` все равно ссылается на глобальный объект (например, `window` в браузере), а не на объект `obj`.

Тк когда объект `obj` создается, `this` ссылается на глобальный объект, потому что `this` находится вне контекста функции.

И тк значение свойства `this.y` еще не определено, оно равно `undefined`.
Когда вы пытаетесь выполнить `++this.y`, происходит попытка инкрементирования `undefined`, и результатом является `NaN`.

---
### _Потеря контекста_

Потеря контекста при сохранении `референса метода`(функции) объекта в переменную

```
const user = {
  name: "John",
  sayHello() {
    return "Hello, " + this.name;
  },
};

const boundFn = user.sayHello;
boundFn(); /=/ Hello, undefined
```

Тк мы вызываем функцию `boundFn()` без контекста(без элемента перед точкой), контекст ссылается не на `user`, а на глобальный объект `windows`.

Решение:

Через `bind` указали контекст - объект к которому нужно обращаться, в частности `user`

```
// const boundFn = user.sayHello;
const boundFn = user.sayHello.bind(user2);
boundFn();
```

Через `call` указали контекст для обращения, вызов происходит сразу же.

```
// const boundFn = user.sayHello;
const boundFn = user.sayHello.call(user2);
```

### _Особенности arrow-func_

- `() =>` В стрелочных функциях значение `this` определяется **_при создании_** функции и не изменяется при вызове функции.
	- При создании, `arrow-func` берет контекст для `this` yна уровень выше. (как и все другие)
	- Но, если разместить `arrow-func` как метод в объекте, то функция будет ссылаться на глобальный объект `window`.
	- **_Стрелочные функции_** не имеют своего собственного контекста (`this`), они **_наследуют контекст родительской функции_**.
- `function()` В обычных функциях значение `this` зависит от контекста, в котором функция была **_вызвана_**, и `this` может быть изменен во время выполнения программы.

---
Сохраняет контекст объекта `user`, тк стрелочная функция получает контекст `this` там где она была объявлена, то-есть в родительской функции:

```
const user = {
  name: "John",

  sayHello() {
    const arrowFn = () => {
      return "Hello, " + this.name;
    };

    return arrowFn();
  },
};

user.sayHello(); // "Hello, John"
```

Не сработает:

```
const user = {
  name: "John",
  sayHello: () => {
    return "Hello, " + user.name;
  }
};

const boundFn = user.sayHello;
boundFn(); /=/ Hello, John
```

Стрелочные функции не имеют своего собственного контекста (`this`), они наследуют контекст родительской функции. 
В данном случае, так как `sayHello` является стрелочной функцией, она будет наследовать контекст глобального объекта, а не объекта `user`. Поэтому вызов `boundFn()` вернет `undefined`.