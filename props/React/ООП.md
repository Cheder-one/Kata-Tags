![[Pasted image 20240309200424.png]]

Два основных понятия Объектно-ориентированной парадигмы:
- **Класс** - Описание сущности
	- **Свойства**
	- **Методы** - То что может `совершать сущность`

![[Pasted image 20240309202113.png]]
- **Объект** - конкретный экземпляр

## _3 основных концепции ООП_

![[Pasted image 20240309202909.png]]

## _Инкапсуляция и Сокрытие_

**Инкапсуляция** - Предоставление `фиксированного интерфейса для взаимодействия` и `сокрытие деталей`.

- **Класс** - Это `капсула`, содержащая и объединяющая `Свойства` и `Методы`(для работы с этими свойствами).
- **Сокрытие**:
	- `Запрет доступа` к приватным свойствам и методам `вне класса`. 
	- Создание `ограниченного доступа `через `геттеры/сеттеры` с условным ветвлением.
 ![[Pasted image 20240309210548.png]]
![[Pasted image 20240309210725.png]]

## _Наследование_

**Наследование** - Каждый `дочерний класс`, `перенимает` все `свойства/методы родителя`. 

![[Pasted image 20240309211154.png]]

Если у родителя и у наследника есть свой `constructor()`, то нужно:
- Вызвать `родительский конструктор` и `передать значения` через `super()`.
- Передать значения `в дочерний конструктор`.

![[Pasted image 20240309212129.png]]

## _Полиморфизм_

**Полиморфизм (много форм)** - `Один интерфейс`, но `разные реакции`. 
Позволяет `переназначить метод базового` класса и `выполнить дочерний` функционал.

```
class Shape {
  draw() {
    console.log("Рисуем форму");
  }
}

class Circle extends Shape {
  draw() {
    console.log("Рисуем круг");
  }
}

const shape = new Shape();
const circle = new Circle();

shape.draw();   // "Рисуем форму"
circle.draw();  // "Рисуем круг"
```

## _Агрегация и Композиция_

**Агрегация и Композиция** - Это `способы взаимодействия между классами`(как и наследование)

- **Композиция** - Класс `содержит другие объекты`, он `использует их внутри себя`. 
  Эти `внутренние` объекты `не могут существовать вне базового класса`(являются его `составными деталями`). Объекты `создаются внутри базового конструктора` класса.

![[Pasted image 20240310170410.png]]

- **Агрегация** - Принимает через `constructor()` инициализированный `обьект из вне`, а `не инициализирует экземпляр внутри` базового класса.

![[Pasted image 20240310171325.png]]
Передаваемый объект `инициализируется и живет отдельно`. 
Если удалить базовый класс, то `инициализированные внутри объекты - удалятся`, а `переданный сторонний обьект` продолжит `существовать`. 

## _Абстрактные классы и интерфейсы_

- **Интерфейс** - `Описывает` как должно быть, но `не реализует`
- **Абстрактные классы** - Способен `абстрактно описывать` + иметь в себе `функционал`.
  Класс который будет `от него наследоваться`, унаследует `свойства и методы` родителя + `должен` будет `реализовать все абстрактные поля`.

![[Pasted image 20240310172534.png]]

## _Интерфейсы_

**Класс:** 
- Может `расширяться только от одного` класса.
- Но может `имплементироваться от нескольких` интерфейсов.

**Имплементация** - Класс `должен реализовывать все поля` которые указаны `в интерфейсе`.

![[Pasted image 20240310173053.png]]

Систему нужно проектировать именно на уровне интерфейсов.

## _Prototype_

- `JS` позволяет `заимствовать методы` и `вызывать` их на `других объектах`. 
  В JavaScript, когда `метод вызывается для объекта`
	1. Движок JavaScript `ищет метод в объекте`. 
	2. Если он не находит метод, он `ищет его в прототипе объекта`. 
	3. Если метод найден в цепочке прототипов, он выполняется. Иначе выдает ошибку.
  Поэтому `внутри методов` объекта, `к его свойствам` мы `обращаемся` через `this`, тк объект может смениться.  А `this` ссылается на `объект` в котором мы сейчас `находимся`, тем самым давая доступ к его свойствам. Следовательно, методы просто переключаться на идентичные свойства другого, подставленного нами, объекта.
- К `переменным` обращаемся `как обычно`.

---
**Приватные свойства** `запрещены для внешнего взаимодействия` с ним. 
- `Запрещено` обращаться к нему как `свойству/методу вне` его класса. 
- `Разрешено` взаимодействие с ним `только внутри` самого класса.

**constructor()** - специальный метод, некоторый `блок инструкций`, который `вызывается при создании Объекта`.

**super()** - Вызывает `родительский конструктор`, передавая свойства 
