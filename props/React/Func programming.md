Это:

1. Создание `маленьких`, `простых функций`, очень понятных и легкочитаемых
2. Выполнение этих простых функций последовательно. (`Композиция функций` - `pipeline`)
3. `Результат` функций `не сохраняется`. Не храним ни конечный ни промежуточный результат.
4. Функции должны быть `чистыми`. Неизменяемость объектов (`immutable`).

4-й пункт означает, что после создания объекта его состояние не может быть изменено. Вместо этого, при необходимости внесения изменений в объект, создается новый объект с обновленными значениями. Можно создавать `неизменяемые объекты` с помощью [[Object.freeze()]] или библиотек `Immutable.js` или `Immer.js`.

Итого: Передаем в начальные функции какие-либо данные -> эти данные проходят через ряд функций -> получаем конечный результат

![[Pasted image 20231231184942.png]]

## _Композиция функций (`pipeline`)_

-> Не подходит для `func prog`, тк приходится хранить `result`

```
const x = 2
const y = x * 2
const z = y * y
```

-> Пример композиции функций `без сохранения` `result`

```
const App = () => {
  const x = 2;

  const double = (num) => num * 2;
  const square = (num) => num * num;
  const half = (num) => num / 2;

  return <h1>{half(square(double(x)))}</h1>ж; /=/ Это неудобочитаемый формат
};
```

-> Реализация через `pipeline`

```
import { compose, pipe } from "lodash/fp";

const App = () => {
  const x = 2;

  const double = (num) => num * 2;
  const square = (num) => num * num;
  const half = (num) => num / 2;

  // const calc = compose(half, square, double);
  const calc2 = pipe(double, square, half);

  return <h1>{calc2(x)}</h1>;
};
```

## _Каррирование_

Как реализовать ситуацию, когда нужно передать доп аргументы?

```
const App = () => {
  // ...
  const divide = (num1, num2) => num1 / num2;

  const calc = pipe(double, square, half, divide(3));
};
```

-> Каррирование

```
const App = () => {
  // ...
  const divide = (divider) => {
    return (num1) => num1 / divider;
  };

  /=/ В `pipeline` не будет ошибки, тк мы возвращаем функцию,
  в которой уже существует переданный делитель

  const calc = pipe(double, square, half, divide(3));
};
```

## _Чистые функции (`pure functions`)_

1. Принимая одно и тоже значение - возвращает одинаковый результат
2. Не зависит от внешних факторов и не подтягивает переменные из окружения.
   Получает все из параметров, тем самым самодокументируясь.
3. Возможность кеширования функции. Тк пока ее параметры не изменились, нет необходимости ее выполнять вновь, тк `пункт 1.`

## _Immutable объект_

Неизменяемость объектов, подразумевает что нужно `создавать новый объект`,
а `не мутировать исходный`.

-> Этот же подход используется в `useState()`

```
const App = () => {
  const [state, setState] = useState({ id: 0 });

  setState((prev) => ({ ...prev, id: 1 }));

  return <h1>App</h1>;
};
```
