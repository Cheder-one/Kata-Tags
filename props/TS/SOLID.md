## _1. Принцип единственной ответственности_

**Single Responsibility** - Это про `декомпозицию`. Не должно быть `God-object`. 
`Одна` конкретная `сущность решает одну` выделенную ей целевую `задачу`.

У каждой сущности `своя зона ответственности`, благодаря `декомпозиции на модули`.

![[Pasted image 20240310175737.png]]

![[Pasted image 20240310175102.png]]

## _2. Принцип открытости и закрытости_

**Open Close** - Сущности должны быть `открыты для расширения`, но `закрыты для изменения`.

`Добавление нового функционала`, должно происходить `не через изменение существующей`, а через `добавление новой сущности`. 

-> **Верно**
![[Pasted image 20240310180307.png]]
-> **Неверно**
![[Pasted image 20240310180239.png]]

## _3. Принцип подстановки Барбары Лисков_

**Lickov Substitution** - `Наследующийся класс` должен **`дополнять`**, а **`не замещать`** `поведение базового класса`.

`Нельзя обнулять методы базового класса в дочерних`, дабы соблюдать предсказуемость кода.


![[Pasted image 20240310185917.png]]

Например: 
Есть 2 класса: `базовый` и `дочерний`.
Есть `функция` которая `принимает` объект - `экземпляр класса`. Внутри нее `вызывается некий метод` который `есть в базовом классе`.
Принцип гарантирует, что `при передаче дочернего экземпляра`, в нем `будут функционировать все методы` которые есть у `базового класса`.

- Должна быть `предсказуемость при работе с наследниками базового класса`.
- Если так `сделать не получается`, то нужно `удалить из базового класса этот метод` и `декомпозировать` его на два дочерних `с уникальными реализациями` методов.

![[Pasted image 20240310202105.png]]
![[Pasted image 20240310201901.png]]

## _4. Принцип разделения интерфейса_

**Interface Segregation** - `Избавляем` программные сущности `от методов которые они не используют`. Дробим обобщенные интерфейсы.

Этот принцип пересекается с
- `1) Принципом единой ответственности` 
- `3) Принципом подстановки Лисков`. 

**Основная суть**: Внутри класса, `не должно быть несвойственных` ему `методов`, которые он `перенял от базового класса`. Для этого, необходимо `разбивать крупные и обобщенные интерфейсы` на более `узкоспециальные`.

![[Pasted image 20240310204111.png]]

![[Pasted image 20240310204236.png]]

## _Принцип инверсии зависимости_

**Dependency invercion** - `Высшие сущности не должны зависеть от деталей` при их замене. 
Для этого `должна быть прослойка абстракции, звено между ними` которое бы сводила взаимодействие с разными деталями `к единообразному интерфейсу`. 

Например, мы можем работать с разными музыкальными источниками API. 
У них есть разные методы, но суть их одна. 

![[Pasted image 20240310211851.png]]

Чтобы увеличить переиспользуемость и универсальность, нужно 
`#1 Создать общий интерфейс для единообразия методов`. 
Так станет доступен Полиморфизм.

![[Pasted image 20240310212242.png]]

**#2 Более улучшенный вариант**

Но может стать так, что нам `необходимо заменить класс с API на другой`. 
Для этого должна быть `одна точка взаимодействия` - звено между клиентом и различными вариациями API, `дабы каждый раз не перезаменять код везде`.

Создаем `абстрактный класс`, который используя полиморфизм, может` вызывать соответствующий метод` из переданного `экземпляра` API.

![[Pasted image 20240310214528.png]]
Ведем любое `взаимодействие с различными API` через `единообразную абстракцию` и `единое место подключения`.

![[Pasted image 20240310214605.png]]
![[Pasted image 20240310214622.png]]