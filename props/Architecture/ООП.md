**Объектно-ориентированное программирование** - Основной акцент на `работе с объектами`. 
Объекты `объединяют` в себе `данные и методы для работы с ними`.

Позволяет `иметь изменяемое состояние внутри объектов`. Это позволяет `моделировать реальные сущности`, например пользователей.

![[Pasted image 20240309200424.png]]

Два основных понятия Объектно-ориентированной парадигмы:
- **Класс** - Описание сущности
	- **Свойства**
	- **Методы** - То что может `совершать сущность`
- **Объект** - конкретный экземпляр

![[Pasted image 20240309202113.png]]

## _3 основных концепции ООП_

![[Pasted image 20240309202909.png]]

## _Инкапсуляция и Сокрытие_

**Инкапсуляция**:
- `Скрытие подкапотных деталей` от внешнего взаимодействия(`приватные свойства`)
- `Реализация доступа` через `геттеры/сеттеры` с условным ветвлением.

- **Класс** - Это `капсула`, объединяющая `Свойства` и `Методы` для их общего взаимодействия. 
 
 -> Доступ к скрытым полям через `get/set` ![[Pasted image 20240309210548.png]]
![[Pasted image 20240309210725.png]]

## _Наследование_

**Наследование** - Каждый `дочерний класс`, `перенимает` все `свойства/методы родителя`. 

![[Pasted image 20240309211154.png]]

Если у родителя и у наследника есть свой `constructor()`, то нужно:
- Вызвать `родительский конструктор` и `передать значения` через `super()`.
- Передать значения `в дочерний конструктор`.

![[Pasted image 20240309212129.png]]

## _Полиморфизм_

## _Статический полиморфизм_

**Статический полиморфизм** - `Основан на перегрузке`, в нем `выбирается подходящий метод` для вызова `на этапе компиляции` кода, в зависимости от входящих данных 
(`является мнимым`)

```
function add(a: number, b: number): number;
function add(a: string, b: string): string;
function add(a: any, b: any): any {
    if (typeof a === 'number' && typeof b === 'number') {
        return a + b; // сложение для чисел
    } else if (typeof a === 'string' && typeof b === 'string') {
        return a.concat(b); // конкатенация строк
    }
}

console.log(add(1, 2)); // вывод: 3
console.log(add("Hello, ", "world!")); // вывод: Hello, world!
```

## _Динамический полиморфизм_

**Полиморфизм (много форм)** - `Один интерфейс`, но `разные реакции`. 

- У `разных объектов` можно вызывать `одинаковый метод`, но `с разной реализацией`.
- Позволяет `переназначить метод базового` класса и `выполнить дочерний` функционал.

```
class Shape {
  draw() {
    console.log("Рисуем форму");
  }
}

class Circle extends Shape {
  draw() {
    console.log("Рисуем круг");
  }
}

const shape = new Shape();
const circle = new Circle();

shape.draw();   // "Рисуем форму"
circle.draw();  // "Рисуем круг"
```

## _Композиция и Агрегация_

**Композиция и Агрегация** - Это `способы взаимодействия между классами`(как и наследование)

- **Композиция** - Класс `содержит другие объекты`, он `использует их внутри себя`. 
  Эти `внутренние` объекты `не могут существовать вне базового класса`(являются его `составными деталями`). Объекты `создаются внутри базового конструктора` класса.

![[Pasted image 20240310170410.png]]

- **Агрегация** - Принимает через `constructor()` инициализированный `обьект из вне`, а `не инициализирует экземпляр внутри` базового класса.

![[Pasted image 20240310171325.png]]
Передаваемый объект `инициализируется и живет отдельно`. 
Если удалить базовый класс, то `инициализированные внутри объекты - удалятся`, а `переданный сторонний обьект` продолжит `существовать`. 

## _Абстрактные классы и интерфейсы_

- **Интерфейс** - `Описывает` как должно быть, но `не реализует`
- **Абстрактные классы** - Способен `абстрактно описывать` + иметь в себе `функционал`.
  Класс который будет `от него наследоваться`, унаследует `свойства и методы` родителя + `должен` будет `реализовать все абстрактные поля`.

![[Pasted image 20240310172534.png]]

## _Интерфейсы_

**Класс:** 
- Может `расширяться только от одного` класса.
- Но может `имплементироваться от нескольких` интерфейсов.

**Имплементация** - Класс `должен реализовывать все поля` которые указаны `в интерфейсе`.

![[Pasted image 20240310173053.png]]

Систему нужно проектировать именно на уровне интерфейсов.

## _Prototype_

- `JS` позволяет `заимствовать методы` и `вызывать` их на `других объектах`. 
  В JavaScript, когда `метод вызывается для объекта`
	1. Движок JavaScript `ищет метод в объекте`. 
	2. Если он не находит метод, он `ищет его в прототипе объекта`. 
	3. Если метод найден в цепочке прототипов, он выполняется. Иначе выдает ошибку.
  Поэтому `внутри методов` объекта, `к его свойствам` мы `обращаемся` через `this`, тк объект может смениться.  А `this` ссылается на `объект` в котором мы сейчас `находимся`, тем самым давая доступ к его свойствам. Следовательно, методы просто переключаться на идентичные свойства другого, подставленного нами, объекта.
- К `переменным` обращаемся `как обычно`.

---
**Приватные свойства** `запрещены для внешнего взаимодействия` с ним. 
- `Запрещено` обращаться к нему как `свойству/методу вне` его класса. 
- `Разрешено` взаимодействие с ним `только внутри` самого класса.

**constructor()** - специальный метод, некоторый `блок инструкций`, который `вызывается при создании Объекта`.

**super()** - Вызывает `родительский конструктор`, передавая свойства 
