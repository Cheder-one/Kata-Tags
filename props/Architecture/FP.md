**Функциональное программирование** - `Функция` это основной `строительный блок`, `возвращает значение` основанное только на `аргументах`. 

## _Ключевые концепции_

### _1. Чистые функции_

- `Одинаковые входные` данные - `одинаковый результат`
- `Возвращает копию`, а `не мутирует` выходные данные 
  (`глубокая копия ссылочных` или `...rest`)
- `Не подтягивает внешние переменные` из окружения

### _2. Функции высшего порядка_

**Функции высшего порядка** - Это те функции, которые `принимают в себя функции` или `возвращают функции`. 

### _3. Рекурсия_

**Рекурсивные функции** - `Функция` которая `вызывает саму себя`, но уже с другими аргументами. Как правило функция состоит из `base case` и `рекурсивного вызова`.

- Часто используются `вместо циклов` при `обходе каждого узла внутри древовидной структуры`(будь то `обьект объектов` или `массив`)

```
const tree = {
  value: 1,
  children: [
    {
      value: 2,
      children: [
        { value: 4, children: [] },
        { value: 5, children: [] }
      ]
    },
    {
      value: 3,
      children: [
        { value: 6, children: [] },
        { value: 7, children: [] }
      ]
    }
  ]
};

function traverseTree(node) {
  console.log(node.value); 
  /=/ Рекурсивно обходим дочерние узлы
	node.children.forEach(child => traverseTree(child)); 
}

traverseTree(tree);
```

### _4. Композиция функций_

**Композиция функций** - Создание новой функции, путем `комбинирования` нескольких `функций`, где `результат одной` функции - является `входными данными для следующей` функции.

```
// Функция для умножения числа на 2
const double = x => x * 2;

// Функция для добавления 1 к числу
const increment = x => x + 1;

// Композиция функций double и increment
const doubleAndIncrement = x => increment(double(x));

console.log(doubleAndIncrement(3)); // Выведет: 7 (2 * 3 + 1)
```

___
## _Терминология_

- **Функция** - `возвращает` одно и то же `значение`, при одинаковых входных данных.
- **Процедура** - вызывается ради `побочных эффектов`
___
- **Сигнатура** - `Количество`, `порядок` и `тип` параметров.
- **Арность** - Количество параметров

### _Императивный и Декларативный подход_

![[Pasted image 20240308163143.png]]

- **Императивный подход** - Расписывает `как сделать`.
- **Декларативный подход** - Указывает на то, `что должно быть сделано`.

### _Замыкание_

**Замыкание** - `Функция` + ее `область видимости`. 
`Создается в момент вызова функции`, получая `доступ к окружающим` ее `значениям`. 

### _Рекурсия_

- **Рекурсия** - Функция `вызывает сама себя`, внутри себя
- **Хвостовая рекурсия** - `В последней итерации` вызова функции, `вызываем функцию`, но уже `со всеми данными` .

![[Pasted image 20240311171854.png]]

### _Функции первого класса_

**Функции первого класса** - Функции `ведут себя как переменные`, как данные. 

Их поддержка зависит от ЯП.
- Присвоить функцию в переменную
- Передать функцию в качестве аргумента
- Возвращать из функции другую функцию

![[Pasted image 20240311172530.png]]

### _Функции высшего порядка (HOF)_

**Функции высшего порядка** - `Принимают` и `возвращают функции`.

- **Методы массивов** - `принимают предикат`, в зависимости `от результата` которого, мы `определяем что делать` с нашими данными.
- **Promise** - Принимает callback с двумя параметрами.

![[Pasted image 20240311174347.png]]

### _Предикат_

**Предикат** - Функция которая `возвращает логическое значение`.

![[Pasted image 20240311174412.png]]

### _Мемоизация_

**Мемоизация** - Функция с памятью.
Если в функцию `передаются те же параметры`, то `не нужно` проводить `повторные расчеты`, `берем` результаты `из кеша`.

![[Pasted image 20240311175432.png]]

## _Отличие функции от метода_

**Функция** 
- `Независимый фрагмент` кода, может быть `определен где угодно`.
- Применяется `для переиспользования логики` в разных частях программы.

**Метод**  
- `Принадлежит объекту` и предназначен `для манипулирования с данными` этого объекта
- Вызываются `через обращение к объекту`. 

