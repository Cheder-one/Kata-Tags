## _Числа_

### _Способы записи числа_

```
let billion = 1000000000;
let billion = 1_000_000_000
let billion = 1e9;  /=/ 1 миллиард, буквально: 1 и 9 нулей
```

### _Хранение чисел_

Внутри JavaScript число представлено в виде 64-битного формата `IEEE-754`. 
Для хранения числа используется `64 бита`: 
- 52 из них используется для хранения `цифр`
- 11 для хранения положения `десятичной точки` 
- 1 бит отведён на хранение `знака`.

Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность `Infinity`

### _Неточные вычисления_

```
0.1 + 0.2 // 0.30000000000000004
0.1 + 0.2 == 0.3; // false
```

Число хранится в памяти в `бинарной` форме, как последовательность бит – единиц и нулей. Но дроби, такие как `0.1`, `0.2`, которые выглядят довольно просто в `10-тичной` системе счисления(`1/10; 2/10`), на самом деле являются `бесконечной` дробью в двоичной форме.

```
- 0.1 (десятичная) = 0.00011001100110011... (двоичная, с бесконечным повторением группы "0011").
- 0.2 (десятичная) = 0.0011001100110011... (двоичная, с бесконечным повторением группы "0011").
- 0.3 (десятичная) = 0.0100110011001100... (двоичная, с бесконечным повторением группы "0011").
```

Другими словами, что такое `0.1`? 
Это единица делённая на десять — `1/10`, одна десятая. В десятичной системе счисления такие числа легко представимы, по сравнению с одной третьей: `1/3`, которая становится бесконечной дробью `0.33333`.

---
В JavaScript нет возможности для хранения точных значений 0.1 или 0.2, используя двоичную систему, точно также, как нет возможности хранить одну третью в десятичной системе счисления.

Числовой формат `IEEE-754` решает эту проблему путём округления до ближайшего возможного числа. Правила округления обычно не позволяют нам увидеть эту «крошечную потерю точности», но она существует.

```
(0.1 + 0.2).toFixed(1) // 0.3
```

---
### _Округление_

- `toFixed()` - округляет значение до `n` знаков после запятой. Возвращает тип `string`.
- `Math.floor` Округление вниз: `3.6` `=>` `3`; `-1.1` `=>` `-2`.
- `Math.ceil` Округление вверх: `3.1` `=>` `4`; `-1.1` `=>` `-1`.
- `Math.round` Округление до целого: `3.1` `=>` `3`, `3.6` `=>` `4`.
- `Math.trunc` Удаление дробной части без округления: `3.1` `=>` `3`; `-1.1` `=>` `-1`

- `parseInt/parseFloat` Для мягкого преобразования значений типа `100px` в число. 
  Данные функции по порядку считывают `число` из `строки` до тех пор пока не возникнет ошибка.

## _Переменные_

### _let и  const_

- `let` - может быть переназначено, но лишь без обьявительного - ключевого слова 
- `const` - не может быть переназначено, но данные типа `object` все равно могут изменяться внутри.

### _Проблематика var_
- У `var` `функциональная` область видимости 
- Переменные `var` предварительно собираются и выносятся в самый верх кода, а их определение происходит в том месте где мы им присваиваем значения.

```
// var car; /=/ происходит виртуальный вынос (hoisting - поднятие)
						переменной вверх кода с неявным присваиванием ей undefined

clonsole.log(car) /=/ undefined (но должна быть ошибка, тк переменной еще нет)
var car = 'bmw'
clonsole.log(car) /=/ bmw
```

- Не выдает ошибку `has alredy declared` при повторном объявлении той же переменной

```
var car = 'bmw'
var car = 'audi' /=/ Мы не будем знать то что мы перезаписали переменную
```

## _Errors_

![[Errors]]

## _Рекурсия_

![[recursion]]

## _Замыкание_

![[closure]]

## _Чистые Функции_

![[pure_function]]

## _Стрелочные функции_

![[arrow_func]]

## _HOF. Функция высшего порядка_

**Функции высшего порядка** - это функции, которые могут принимать другие функции в качестве аргументов или возвращать их как результат.

Например, встроенные функции JavaScript `Array.prototype.map`, `Array.prototype.filter` и `Array.prototype.reduce` являются функциями высшего порядка.

```
function question(job) {
  const jobDictionary = {
    developer: "вход выполнен как разработчик",
    curator: "вход выполнен как наставник",
  };

  return function (name) {
    return `${name}, ${jobDictionary[job]}`;
  };
}

const devQuestion = question("developer");
devQuestion("Denis");
```

### *_.map()*

Метод `map()` итерируется по входному массиву и изменяет каждый его элемент согласно коду функции-`callback` которую мы передаем. Возвращает новый измененный массив.

Метод `map` принимает `callback` с 3 параметрами:
1. `element`: текущий элемент массива 
2. `index`: index текущего элемента в массиве (начиная с 0).
3. `array`: сам входной массив.
 
### *_.filter*
  
Метод `filter()` создаёт, на основе входного массива, новый массив, в которой попадают элементы соответствующие условию которое было задано в теле функции `callback`

### *_.reduce*

Метод принимает два параметра: `callback` и необязательное начальное значение (`initialValue`)
  
`Коллбэк` принимает четыре параметра: 
- `accumulator` (аккумулятор) 
- `currentElement` (текущее значение) 
- `currentIndex` (текущий индекс) 
- `sourceArray` (исходный массив).

Если `initialValue` не задан, то в `accumulator` будет записан первый элемент массива, а в `currentElement` — второй.

```
array.reduce((аккумулятор, элемент, индекс, исходный массив) => {
	// тело функции
}, начальное значение)
```

На каждой итерации, функция-`callback` принимает два аргумента: `accumulator` и `currentElement`. 
Функция выполняет операцию над `accumulator` и `currentElement` и возвращает результат, который затем становится новым значением `acc` для следующей итерации. 

## _Циклы_

### _while()_

Выполняется до тех пор, пока условие истинно

```
let i = 0

while (i++ < 10) { /=/ Сначала сравнивает, а "на следующей строчке" увеличивает
	console.log(i) /=/ 1 2 3 ... 10
}

while (++i < 10) { /=/ Сначала увеличивает, потом сравнивает
	console.log(i) /=/ 1 2 3 ... 9
}

i = 10
while (i--) {
	console.log(i) /=/ 9 8 7 ... 0
}
```

### _do while()_

Сначала выполнит действие, а потом произойдет проверка условия

```
let i = 10;

do {
	console.log("action" + i); /=/ action10 ... action0
} while (i--);
```

### _for_

![[for]]

## _Методы массивов_

- `push` добавляет элементы в конец массива.
- `pop` удаляет и возвращает последний элемент массива.
- `shift` удаляет и возвращает первый элемент массива, сдвигая все остальные элементы на одну позицию влево.
- `unshift` добавляет элементы в начало массива, сдвигая все существующие элементы вправо.

## _Получить массив аргументов функции_

![[func_args]]

## _Логические операторы_

- `||` - Возвращает первое `true`.
  Если `true` не нашлось, то возвращает `последнее false`

```
value = 1 || 0 /=/ 1

value = 0 || 0 || null /=/ null
```

- `&&` - Пытается вернуть первое `false`.
  Если `false` не нашлось, то возвращает `последнее true`

```
value = 1 && 0 && 3 /=/ 0

value = 1 && 2 && 3 /=/ 3
```

## _Разница инкриментов_

![[count++ & ++count]]

- `indexOf()` - поиск `index-а` элемента в массиве или строке
- `slice()` - извлекает подстроку или подмассив
  - подстрока/подмассив - последовательность элементов(часть) из исходного элемента
- `replace()` - заменяет первое вхождение (совпадение)

```
let str = 'Hello, World!';
let newStr = str.replace('Hello', 'Hi'); // 'Hi, World!'
```

