## _Обработка ошибок_

```
try {
  console.log(undefVar);
} catch (error) {
  console.log(error.name);     /=/ Выводит имя ошибки
                                  (в данном случае "ReferenceError")
  console.log(error.message);  /=/ Выводит сообщение об ошибке
																  (в данном случае "undefVar is not defined")
  console.log(error.stack);    /=/ Выводит стек вызовов.
																  Содержит информацию о месте, где произошла ошибка.
}
```
#стек_вызовов

### _Проброс исключений_

Для его реализации нам достаточно проверить во внутреннем блоке `catch` тип ошибки и, если она не соответствует `Error`, то передать дальше:

```
// let res = 0;
try {
  res = divide(1, 2);
  console.log(res);
} catch (error) {
  if (error.name == "Error") {
    console.log(error.name);
    console.log(error.message);
  } else {
    throw error; /=/ Проброс ошибки наверх
  }
}
```

Соответственно, внутри будет обрабатывать только исключения `Error`, а остальные пробрасывать блокам более высокого уровня.

```
try {
    return getData(key);
} catch (error) {
    if (error instanceof NotFoundError) {
      throw error; /=/ Проброс ошибки наверх
    }
}
```

#проброс*ошибки*наверх

### _Создание пользовательских Errors_

В этом примере, если функция `getData` вызывает ошибку `NotFoundError`, она будет выброшена с помощью оператора `throw` и поймана в блоке `try-catch` внутри функции `process`.
Затем можно обработать исключение `NotFoundError` в блоке `catch` с помощью условного оператора `if`.

```
function getData() {
  // Логика получения данных
  if (условие) {
    throw new NotFoundError("Данные не найдены");
  }
}

function process() {
  try {
    getData();
  } catch (error) {
    if (error instanceof NotFoundError) { /=/ true
      // Обработка исключения NotFoundError
    } else {
      // Обработка других исключений
    }
  }
}
process()
```
#обработка_исключений

```
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

// Использование

function readUser(json) {
  let user = JSON.parse(json);

  if (!user.age) {
    throw new ValidationError("Нет поля: age");
  }
  if (!user.name) {
    throw new ValidationError("Нет поля: name");
  }
  return user;
}

// Рабочий пример с try..catch

try {
  let user = readUser('{ "age": 25 }');
} catch (err) {
  if (err instanceof ValidationError) {
    alert("Некорректные данные: " + err.message);
    // Некорректные данные: Нет поля: name
  } else if (err instanceof SyntaxError) {
    alert("JSON Ошибка Синтаксиса: " + err.message);
  } else {
    throw err;
    // Неизвестная ошибка, пробросить исключение
  }
}
```

## _Асинхронность_

Если вы хотите получить `значение`, возвращаемое после определенного `времени`, вы можете использовать `промисы` или `асинхронные функции`.

```
let fileSizes = {
  testFile1: 65,
  testFile2: 48
};

function getFileSize(filename, cb) {
  setTimeout(() => cb(fileSizes[filename]), Math.random() * 500);
}

async function sumFileSizes(filename1, filename2, cb) {
  try {
    const size1 = await new Promise((resolve) => {
      getFileSize(filename1, resolve);
    });
    const size2 = await new Promise((resolve) => {
      getFileSize(filename2, resolve);
    });

    return cb(size1 + size2);
  } catch (error) {
    console.log(error);
  }
}

sumFileSizes("testFile1", "testFile2", (sum) => {
  return sum; /=/ 113
});
```

### _Callback_

![[callback]]

---
Переписывание асинхронного `коллбэка` в приемлемый вид

```
async function pageLoader(callback) {
  const data = await fetch("https://jsonplaceholder.typicode.com/todos/1");
  callback(data);
}

function pageLoader(callback) {
  fetch("https://jsonplaceholder.typicode.com/todos/1")
    .then((response) => response.json())
    .then((data) => callback(data))
    .catch((error) => console.error(error));
}

async function pageLoader(callback) {
  try {
    const response = await fetch("https://jsonplaceholder.typicode.com/todos/1");
    const json = await response.json();
    callback(json);
  } catch (error) {
    console.error(error);
  }
}

function getAjax(data) {
  console.log("Запрос послан");
  console.log("Ответ сервера");
  console.log(data);
}

pageLoader(getAjax);
```

### _Promise_

![[promises]]

## _Event Loop_

`Event Loop` - цикл событий. Его идея заключается в том, что есть бесконечный цикл, в котором движок языка JavaScript ожидает задачи, выполняет их и снова ожидает появление новых задач.

1. `Callback Stack`- первый пришел — последний ушел (стакан)
2. `Microtask Queue` - первый пришел — первый ушел (очередь)
3. `Callback Queue` - первый пришел — первый ушел (очередь)

1) `Callback Stack` (также известный как `Call Stack`) - отвечает за выполнение `синхронного` кода. Он работает по принципу "`первый пришел - последний ушел`" (стакан).
2) `Microtask Queue` (также известная как `Job Queue` или `Promise Queue`) - это механизм, который отвечает за выполнение `микрозадач` (например, `промисов`).
Он работает по принципу "`первый пришел - первый ушел`" (очередь).
3) `Callback Queue` (также известная как `Task Queue` или `Message Queue`) - это механизм, который отвечает за выполнение `колбэков асинхронных операций`, таких как `таймеры` или `events`. Он также работает по принципу "`первый пришел - первый ушел`" (очередь).

Как только `Event Loop` прошелся по всему `Callback Stack` и достиг последней строчки идет смотреть `Callback Queue`.
Если он обнаруживает там элемент, то он закидывает его в `Callback Stack`

### _Call Stack_

```
console.log('start');
console.log(1);
console.log(2);
console.log(3);
console.log('end');

// Вывод:
// start
// 1
// 2
// 3
// end
```

В данном примере мы последовательно выводим определенные значения. При этом, движок JavaScript действует следующим образом:

1. Начинает выполнение новой задачи и кладет ее в стек.
2. После полного выполнения задачи вынимает ее из стека и начинает выполнение новой задачи, если таковая имеется.

![[Pasted image 20231025214119.png]]

### _Стек вызовов_

Вообще сам по себе `Stack` (`стек`) — это структура данных, элементы в которой действуют по принципу
“`последним пришел - первым ушел`”
(`LIFO: last in, first out`).

Стек можно сравнить с коробкой, в которую мы кладем вещи одну на другую. Чтобы достать самую нижнюю вещь, которую мы положили первой, нам необходимо вытащить то, что находится над ней.

![[Pasted image 20231025212425.png]]

### _Callback queue (очередь задач)_

`Задачи` из очереди выполняются по правилу “`первый пришел — первый ушел`”
(`FIFO: first in, first out`)

```
console.log("start");
console.log(1);
setTimeout(function () {
  console.log(2);
}, 0);
console.log(3);
console.log("end");

// Вывод:
// start
// 1
// 3
// end
// 2
```

![[Pasted image 20231025213518.png]]

