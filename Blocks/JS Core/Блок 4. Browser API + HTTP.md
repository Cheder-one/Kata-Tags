В соответствии с объектной моделью документа («`Document Object Model`», коротко `DOM`), каждый `HTML-тег` является `объектом`. Вложенные `теги` являются «детьми» родительского элемента. `Текст`, который находится внутри тега, также является `объектом`.

Все эти `объекты` доступны при помощи JavaScript, мы можем использовать их для изменения страницы. Например, `document.body` – объект для тега `<body>`.

## _Узлы HTML_

```
<!DOCTYPE HTML>
<html>
<head>
  <title>О лосях</title>
</head>
<body>
  Правда о лосях.
</body>
</html>
```

- Каждый `узел` этого дерева – это `объект`.
- `Теги` являются _`узлами-элементами`_ (или просто `элементами`). Они образуют `структуру` дерева: `<html>` – это корневой узел, `<head>` и `<body>` его дочерние узлы и т.д.
- `Текст` внутри `элементов` образует _`текстовые узлы`_, обозначенные как `#text`.
  `Текстовый узел` содержит в себе _только строку текста_. У него _не может быть потомков_, т.е. он находится всегда на самом нижнем уровне.

`Пробелы` и `переводы строки` – это полноправные символы, как буквы и цифры. Они образуют `текстовые узлы` и становятся частью дерева `DOM`.
Так, в примере выше в теге `<head>` есть несколько пробелов перед `<title>`, которые образуют текстовый узел `#text`.

![[Pasted image 20231103145025.png]]

1. По историческим причинам `пробелы` и перевод строки перед тегом `<head>` `игнорируются.`
2. Если мы записываем что-либо после закрывающего тега `</body>`, браузер автоматически перемещает эту запись в конец `body`.

Здесь `пробельных текстовых` узлов нет:

```markup
<!DOCTYPE HTML>
<html><head><title>О лосях</title></head><body>Правда о лосях.</body></html>
```

---

Все, что есть в `HTML`, даже `комментарии`, является частью `DOM`.

4 основных типа узлов:
1. `document` – «входная точка» в DOM.
2. `узлы-элементы` – HTML-теги, основные строительные блоки.
3. `текстовые узлы` – содержат текст.
4. `комментарии` – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.

---
## _Методы получения узлов и элементов_

### _Получить элемент `после` div_

- `li.nextSibling` - вернет следующий узел после указанного `li`. И вероятнее всего следующим узлом будет `#text` (`пробел`, `перенос`)
- `li.nextElementSibling` - вернет следующий `элемент` после `li`.

![[Pasted image 20231103151316.png]]

### _Получить `первый` элемент в div_

- `li.firstChild` - вернет первый `узел` внутри `родителя`. (который вероятнее всего будет `текстовым узлом`)
- `li.firstElementChild` - вернет первый вложенный `элемент` внутри указанного `родителя`

![[Pasted image 20231103152403.png]]

### _Получить `родителя` div_

- `div.parentElement` вернет `родительский элемент` элемента `div`.
- `div.parentNode` вернет `родительский узел` элемента `div`, включая `текстовые узлы` и `комментарии`, и `элементы`.

### _Получить `ближайшего родителя` div_

Свойство `.closest` используется для поиска ближайшего родительского элемента, соответствующего заданному селектору. Оно начинает `поиск` с текущего элемента и продолжает `вверх` по `DOM-дереву`.

```
<div class="parent">
  <div class="child">
    <span class="target">Целевой элемент</span>
  </div>
</div>
```

```
const targetElement = document.querySelector('.target'); const parentElement = targetElement.closest('.parent');
```

### _classList_

![[_.classList._]]

### _Атрибуты_

![[_.getAttribute()]]

## _Типы коллекций HTML_

![[_.children]]

## _Манипуляция элементами_

### _.appendChild()_

![[_.appendChild()]]

### _.insertAdjacentElement()_

![[_.insertAdjacentElement()]]

### _Правильное добавление элементов_

![[_.createDocumentFragment()]]

### _Удаление элементов_

```
title.remove()
title.parentElement.removeChild(title) /=/ Более старый метод
```
#удаление_DOM-элементов

## _События_

![[_.addEventListener()]]

### _Event. Делегирование событий_

![[event & bubbling]]

## _localStorage_

![[localStorage]]

## _AJAX_

`JavaScript` может `отправлять` сетевые `запросы` на сервер и `подгружать` новую информацию `по мере необходимости`. Отправка `сетевых запросов` из JavaScript называется термином «`AJAX`» (**A**synchronous **J**avaScript **A**nd **X**ML).

Формат `XML` мы использовать не обязаны, просто термин `старый`, поэтому в нём есть это слово. `XML` - это язык разметки, используемый для представления структурированных данных. (сейчас вместо него используется `JSON`)

### _Запросы и получение data с сервера_

### _XHR_

`XMLHttpRequest` – это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки страницы.

Несмотря на наличие слова `XML` в названии, `XMLHttpRequest` может работать с любыми данными, а не только с `XML`. Мы можем загружать/скачивать файлы, отслеживать прогресс и многое другое.

### _Основы_

`XMLHttpRequest` имеет два режима работы: `синхронный` и `асинхронный`.

Чтобы сделать `асинхронный` запрос, нам нужно выполнить три шага:

1. Создать `объект` запроса `XMLHttpRequest`
``` 
let xhr = new XMLHttpRequest(); 
/=/ Конструктор не принимает аргументов
```
___
2. Инициализировать и `конфигурировать` `соединение`.
``` 
xhr.open(method, URL, [async, user, password])
```

Вызов `open`, вопреки своему названию, не открывает соединение. Он лишь `конфигурирует` запрос, но непосредственно отсылается запрос только лишь после вызова `send`.

- `method` – HTTP-метод. Обычно это `GET` или `POST`.
- `URL` – куда отправляется запрос: `строка`, может быть и `объект URL`.
- `async` – если указать `false`, тогда запрос будет выполнен `синхронно`.
- `user`, `password` – логин и пароль для базовой `HTTP-авторизации` (если требуется).

___
3. Установить соединение и послать запрос.
```
xhr.send([body])
```

Необязательный параметр `body` содержит тело запроса. 
Некоторые типы запросов, такие как `GET`, не имеют тела. А некоторые, как, например, `POST`, используют `body`, чтобы отправлять `данные на сервер`. 

___
4. Слушать события на `xhr`, чтобы получить ответ.

Это обычные события 
- `load` – событие происходит когда `получен` какой-либо `ответ`(включая ответы с `HTTP-ошибкой`, например `404`).  (*общение с сервером успешно*)
- `error` – когда запрос не может быть выполнен, например, `нет соединения` или `невалидный URL`. (*общение с сервером не успешно*)
- `progress` – происходит периодически во время `загрузки` ответа, сообщает о `прогрессе`.

**_! Слушатель необходимо добавлять перед отправкой `send()`_**

``` 
xhr.onload = function() {
  console.log(`Загружено: ${xhr.status} ${xhr.response}`);
};

/=/ Происходит, только когда общение с сервером не успешно
xhr.onerror = function() { 
  console.log(`Ошибка соединения`);
};

/=/ Запускается периодически
xhr.onprogress = function(event) { 
  /=/ event.loaded - количество загруженных байт
  /=/ event.lengthComputable = равно true, если сервер присылает заголовок Content-Length
  /=/ event.total - количество байт всего (только если lengthComputable равно true)
  console.log(`Загружено ${event.loaded} из ${event.total}`);
};
```
---

```
const url = "https://jsonplaceholder.typicode.com/users";  
  
const xhr = new XMLHttpRequest();  
xhr.open("GET", url);  
  
xhr.onload = () => {  
  if (xhr.status === 200) {  
    const users = JSON.parse(xhr.response);  
    console.log(users);  
  }  
};  
	==/OR/==  
xhr.responseType = "json";  

xhr.onload = () => {  
  if (xhr.status >= 400) {  
		console.error(xhr.response);
  } else {  
    console.log(xhr.response);  
  }  
};  

xhr.send();
```

### _Реализация с Promise_

```
const requestURL = "https://jsonplaceholder.typicode.com/users";  
  
function sendRequest(method, url, body = null) {  
  return new Promise((resolve, reject) => {  
    const xhr = new XMLHttpRequest();  
  
    xhr.open(method, url);  
  
    xhr.responseType = "json";  
    xhr.setRequestHeader('Content-Type', 'application/json')  
    /=/ Явно указываем серверу формат в котором отправляем данные  
  
    xhr.onload = () => {  
      if (xhr.status >= 400) {  
        reject(xhr.response);  
      } else {  
        resolve(xhr.response);  
      }  
    };  
  
    xhr.onerror = () => {  
      reject(xhr.response);  
    };  
  
    // xhr.send(body); /=/ При отправке преобразуется в string. [object Object]  
    xhr.send(JSON.stringify(body));  
  });  
}  
  
// sendRequest("GET", requestURL)  
//   .then((data) => console.log(data))  
//   .catch((err) => console.log(err));  
  
const body = {  
  name: 'username',  
  age: 23  
}  
  
sendRequest("POST", requestURL, body)  
  .then((data) => console.log(data))  
  .catch((err) => console.log(err));
```

### _Метод для конвертации доступен единожды_

```
const requestURL = "https://jsonplaceholder.typicode.com/users";  
  
fetch(requestURL).then((response) => {  
  console.log(response.json()); /=/ <state>: "fulfilled"
  console.log(response.json()); /=/ TypeError: Response.json: Body has already been consumed.  
});
```

![[Pasted image 20231104215138.png]]

## _Fetch_

Метод `fetch()` позволяет получать данные по сети `асинхронно`.
Возвращает `Promise`.

```
let promise = fetch(url, [options])

const getAllTodoes = () => {
	fetch('https://jsonplaceholder.typicode.com/todos', {
	method: 'GET', /=/ GET, POST, DELETE...

	headers: { 'Content-Type': 'application/json' } 
  /=/ При `POST` указываем серверу формат в котором отправляем данные
})
```

Без `options` это простой `GET-запрос`, скачивающий содержимое по адресу `url`.

```
const requestURL = "https://jsonplaceholder.typicode.com/users";  
  
function sendRequest(method, url, body = null) {  
  const headers = {  
    'Content-Type': 'application/json'  
  }  
  
  return fetch(url, {  
    method: method,  
    body: JSON.stringify(body), /=/ При `POST` конвертируем объект в JSON  
                                   (иначе будет [object Object])    
    headers: headers  
  })  /=/ Возвращает Promise  
    .then(response => {  
      if (response.ok) {  
        return response.json() /=/ Встроенный метод конвертации ответа в JSON  
      }  
      
      return response.json().then(error => {  
        const err = new Error('Что-то пошло не так')  
        err.data = error  
        throw err  
      })  
    })  
}

// sendRequest("GET", requestURL)  
//   .then((data) => console.log(data))  
//   .catch((err) => console.log(err));  
  
const body = {  
  name: 'username',  
  age: 23  
}  
  
sendRequest("POST", requestURL, body)  
  .then((data) => console.log(data))  
  .catch((err) => console.log(err));
```
---

-> Other Example
```
const getAllTodoes = () => {
	fetch('https://jsonplaceholder.typicode.com/todos', {
	method: 'GET', /=/ GET, POST, DELETE..
})
	.then((responseValue) => {
		if (!responseValue.ok) { /=/ Eсли HTTP-статус в диапазоне 200-299
			/=/ ok - произошел ли запрос успешно
			throw new Error('Ошибка запроса');
			/=/ throw - выбрасывает ошибку и переводит в блок .catch()
		}
		return responseValue.json();
		/=/ Декодирование запроса
	})
	.then((todoes) => {
		/=/ Передаем дальше декодированный запрос
		todoes.forEach((el, i, arr) => {
			const todoHTML = createTodoElement(el.title);
			dataContainer.append(todoHTML);
		});
	})
	.catch((error) => {
		console.log('error:', error);
	})
	.finally(() => {
		toggleLoader();
	})
};
getAllTodoes()
```

### _Заголовки ответа_

Заголовки ответа хранятся в похожем на `Map` объекте `response.headers`.
Это не совсем `Map`, но мы можем использовать такие же методы, как с `Map`, чтобы получить заголовок по его имени или перебрать заголовки в цикле:

``` 
let response = await fetch(
	'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits'
);

/=/ Получить один заголовок
console.log(response.headers.get('Content-Type')); /=/ application/json harset=utf-8

/=/ Перебрать все заголовки
for (let [key, value] of response.headers) {
  console.log(`${key} = ${value}`);
}
```

### _POST-запрос_

Код отправляет объект `user` как `JSON`:
``` 
let user = {
  name: 'John',
  surname: 'Smith'
};

let response = await fetch('/article/fetch/post/user', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: JSON.stringify(user)
});

let result = await response.json();
console.log(result.message);
```

Заметим, что так как тело запроса `body` – строка, то заголовок `Content-Type` по умолчанию будет `text/plain;charset=UTF-8`.

Но, так как мы посылаем `JSON`, то используем параметр `headers` для отправки вместо этого `application/json` - правильный `Content-Type` для `JSON`.

## _Коды ответа HTTP_

Код ответа (`состояния`) HTTP показывает, был ли успешно выполнен определённый HTTP запрос. Коды сгруппированы в 5 классов:

1. `Информационные:` `100 - 199`
2. `Успешные:` `200 - 299`
3. `Перенаправления:` `300 - 399`
4. `Клиентские ошибки:` `400 - 499`
5. `Серверные ошибки:` `500 - 599`

## _HTTP, DNS, REST_

### _Хостинг_

Веб-хостинг похож на аренду места в Интернете. Когда вы подписываетесь на услугу веб-хостинга, вы, по сути, арендуете место на физическом или виртуальном сервере, где вы можете хранить все файлы и данные, необходимые для работы вашего веб-сайта.

### _DNS_

`Сайт`состоит из `файлов` которые `хранятся` на другом компьютере в сети - `на сервере`. Чтобы `достучаться` до другого компа(`сервера`) нужно знать его `ip-адрес`.

`DNS` - это аналог огромной `телефонной книги`. Он позволяет найти `ip-адрес` сайта по его `доменному имени`. DNS - `Domain Name System` (система доменных имен)

![[Pasted image 20231114193122.png]]

### _Структура DNS_

Структура `DNS` является иерархической. Она выделяет зоны ответственности, где каждый родитель знает о расположении своего дочернего сервера, и знает зону его ответственности.

То есть DNS-сервер домена `.io` знает о том, где расположен домен `hexlet`, DNS-сервер которого знает о расположении своих поддоменов.

![[Pasted image 20231114211025.png]]

### _Что происходит при поиске?_

1. При вводе `доменного имени сайта`, мы начинаем `поиск` адреса его сервера - `ip`
2. Сначала ищем локально, в `кеше` и в файле `hosts`
3. Если ничего не нашли, то обращаемся к `DNS Resolver`(он так же проверяет свой кеш)
   Обычно резолвер-сервер это твой интернет-провайдер (`ISP`). Все резолверы должны `знать` одно: где найти `корневой сервер`.

![[Pasted image 20231114214341.png]]

4. Обращаемся к `Root-серверу` - хранилищу верхнеуровневых(`TLD`) доменов 
   
![[Pasted image 20231114212906.png]]
   
5. `Root-сервер` не знает к кому принадлежит конкретное `доменное имя`, но знает `сервер верхнего уровня`(`TLD`), который знает где найти данный сайт.

![[Pasted image 20231114215749.png]]

6. Вероятно `TLD-сревер` тоже не знает где точно найти наш сайт и перенаправляет нас на `Host-сервер`, туда где наш сайт арендует цифровое пространство.
   
   Обычно за каждым `доменом` закреплено более одного `именного сервера`. Несколько серверов-дубликатов повышает надежность и устойчивость доменной системы к отказам и обеспечивает более быстрое разрешение доменных имен для пользователей.
   
   ![[Pasted image 20231114223603.png]]
  
7.  Мы получили `ip-адрес` сайта и теперь можем обратиться к нему для проверки на то что сайт `не упал`, и если так, то `скачиваем сайт` 
   
   ![[Pasted image 20231114223913.png]]
   
   8. `DNS Resolver` сохраняет в кеш найденный сайт, чтобы не проходить всю эту цепочку вновь. И возвращает найденный адрес сайта в браузер, чтобы тот все загрузил.

### _Handshake. Установка соединения_

`TLS Handshake`(`переговоры TLS`) - это процесс установления `безопасного соединения` между `клиентом` и `сервером`, используя протокол `TLS` (`Transport Layer Security`). 
Этот процесс происходит перед началом фактического обмена данными между клиентом и сервером.

Вот основные шаги, которые происходят в процессе `TLS Handshake`:

1. Приветствие (Hello): Клиент и сервер обмениваются своими `версиями TLS` и `поддерживаемыми алгоритмами шифрования`.
2. Защита (Security): На основе доступных `алгоритмов`, сервер `запускает` дорогостоящий метод `ассиметричного шифрования`, для создания `публичного ключа`. 
3. Аутентификация (Authentication): `Сервер` может отправить цифровой `сертификат` для подтверждения своей подлинности. Клиент может проверить валидность сертификата и убедиться, что сервер является `доверенным`.
4. Обмен ключами (Key Exchange): Клиент и сервер `обмениваются` `публичными ключами` или соглашаются на секретные ключи для дальнейшего шифрования и расшифровки данных.
   - `Публичный ключ` приходит к `клиенту` от сервера вместе с сертификатом. Он позволяет `зашифровать` передаваемые `данные` от клиента к серверу.
   - `Приватный ключ` находится только `у сервера`. Он позволяет `расшифровать` зашифрованную информацию от клиента.
   - `Сертификат` подтверждает `подлинность` публичного  ключа, то что он принадлежит серверу, а не мошеннику.
5. Завершение (Finish): Клиент и сервер обмениваются сообщениями, подтверждающими успешное завершение процесса TLS Handshake. Далее уже используется `симметричное шифрование`(более экономное). После этого они готовы к безопасному обмену данными.
 
![[Pasted image 20231114232402.png]]

### _Получаем разметку. WebServer + NGINX_

`NGINX` - Веб-сервер выполняющий `балансировку` и `распределение` трафика/нагрузки между нашими несколькими серверами.

![[Pasted image 20231114232741.png]]

Так же с помощью него мы можем `разделить` и `изолировать` части нашего сайта. 
Тогда при падении одной части, другая останется.

![[Pasted image 20231114232952.png]]

### _Page Rendering_

- `DOM` - предоставляет браузеру `структуру` того что нужно отобразить.
- `CSSOM` - предоставляет `структуру` как нужно отобразить. 
  Браузер проходится по тегам `link` которые содержат в себе стили, так он определяет модель `CSSOM` - стили которые нужно отобразить.
  ![[Pasted image 20231114234254.png]]
- В `Render Tree`(`дерево отрисовки`) позволяет понять браузеру что рисовать и как рисовать. В нем отображается только то что должно быть отрисовано. Следовательно, все `скрытые` элементы туда `не попадают`, как и теги на подобии `<script>` 

![[Pasted image 20231114233319.png]]

- `Layout Operation` - операция `расстановки`. Определяет что будет находиться в каждом пикселе. 
  На входе мы имеем `размеры элементов`, размер нашего `экрана`. Пропустив `Layout Operation` через `графический движок рендера`(например `Render 3`), на выходе мы получим размеры конечной картинки.
- `Paint Operation` - `определяем` какой `цвет` будет в каждом конкретном пикселе.
- `Coposing Operation` - после того как мы узнали что будет в каждом пикселе и какого он будет цвета, запускаем `операцию отрисовки` с помощью графического процессора.
  Эта операция идет в несколько потоков для получения картинки как можно быстрее.

![[1699995728.656827.mp4]]

### _Итого_

- Браузер делает запрос к `DNS-серверам`, у которых `узнает` необходимый `IP-адрес`
- Браузер устанавливает соединение с веб-сервером, используя протоколы `TCP/IP`
- Браузер делает `HTTP-запрос`
- `Веб-сервер возвращает HTML` страницу для указанного адреса
- `Браузер отрисовывает HTML`

![[Pasted image 20231114193642.png]]