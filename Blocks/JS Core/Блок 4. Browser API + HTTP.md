В соответствии с объектной моделью документа («`Document Object Model`», коротко `DOM`), каждый `HTML-тег` является `объектом`. Вложенные `теги` являются «детьми» родительского элемента. `Текст`, который находится внутри тега, также является `объектом`.

Все эти `объекты` доступны при помощи JavaScript, мы можем использовать их для изменения страницы. Например, `document.body` – объект для тега `<body>`.

## _Узлы HTML_

```
<!DOCTYPE HTML>
<html>
<head>
  <title>О лосях</title>
</head>
<body>
  Правда о лосях.
</body>
</html>
```

- Каждый `узел` этого дерева – это `объект`.

- `Теги` являются _`узлами-элементами`_ (или просто `элементами`). Они образуют `структуру` дерева: `<html>` – это корневой узел, `<head>` и `<body>` его дочерние узлы и т.д.

- `Текст` внутри `элементов` образует _`текстовые узлы`_, обозначенные как `#text`.
  `Текстовый узел` содержит в себе _только строку текста_. У него _не может быть потомков_, т.е. он находится всегда на самом нижнем уровне.

`Пробелы` и `переводы строки` – это полноправные символы, как буквы и цифры. Они образуют `текстовые узлы` и становятся частью дерева `DOM`.
Так, в примере выше в теге `<head>` есть несколько пробелов перед `<title>`, которые образуют текстовый узел `#text`.

![[Pasted image 20231103145025.png]]

1. По историческим причинам `пробелы` и перевод строки перед тегом `<head>` `игнорируются.`
2. Если мы записываем что-либо после закрывающего тега `</body>`, браузер автоматически перемещает эту запись в конец `body`.

Здесь `пробельных текстовых` узлов нет:

```markup
<!DOCTYPE HTML>
<html><head><title>О лосях</title></head><body>Правда о лосях.</body></html>
```

---

Все, что есть в `HTML`, даже `комментарии`, является частью `DOM`.

4 основных типа узлов:

1. `document` – «входная точка» в DOM.
2. `узлы-элементы` – HTML-теги, основные строительные блоки.
3. `текстовые узлы` – содержат текст.
4. `комментарии` – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.

---

## _Методы получения узлов и элементов_

### _Получить элемент `после` div_

- `li.nextSibling` - вернет следующий узел после указанного `li`. И вероятнее всего следующим узлом будет `#text` (`пробел`, `перенос`)
- `li.nextElementSibling` - вернет следующий `элемент` после `li`.

![[Pasted image 20231103151316.png]]

### _Получить `первый` элемент в div_

- `li.firstChild` - вернет первый `узел` внутри `родителя`. (который вероятнее всего будет `текстовым узлом`)
- `li.firstElementChild` - вернет первый вложенный `элемент` внутри указанного `родителя`

![[Pasted image 20231103152403.png]]

### _Получить `родителя` div_

- `div.parentElement` вернет `родительский элемент` элемента `div`.
- `div.parentNode` вернет `родительский узел` элемента `div`, включая `текстовые узлы` и `комментарии`, и `элементы`.

### _Получить `ближайшего родителя` div_

Свойство `.closest` используется для поиска ближайшего родительского элемента, соответствующего заданному селектору. Оно начинает `поиск` с текущего элемента и продолжает `вверх` по `DOM-дереву`.

```
<div class="parent">
  <div class="child">
    <span class="target">Целевой элемент</span>
  </div>
</div>
```

```
const targetElement = document.querySelector('.target'); const parentElement = targetElement.closest('.parent');
```

### _classList_

![[_.classList._]]

### _Атрибуты_

![[_.getAttribute()]]

## _Типы коллекций HTML_

![[_.children]]

## _Манипуляция элементами_

### _.appendChild()_

![[_.appendChild()]]

### _.insertAdjacentElement()_

![[_.insertAdjacentElement()]]

### _Правильное добавление элементов_

![[_.createDocumentFragment()]]

### _Удаление элементов_

```
title.remove()
title.parentElement.removeChild(title) /=/ Более старый метод
```

#удаление_DOM-элементов

## _События_

![[_.addEventListener()]]

### _Event. Делегирование событий_

![[event & bubbling]]

## _localStorage_

![[localStorage]]

## _AJAX_

`JavaScript` может `отправлять` сетевые `запросы` на сервер и `подгружать` новую информацию `по мере необходимости`. Отправка `сетевых запросов` из JavaScript называется термином «`AJAX`» (**A**synchronous **J**avaScript **A**nd **X**ML).

Формат `XML` мы использовать не обязаны, просто термин `старый`, поэтому в нём есть это слово. `XML` - это язык разметки, используемый для представления структурированных данных. (сейчас вместо него используется `JSON`)

### _Запросы и получение data с сервера_

### _XHR_

`XMLHttpRequest` – это встроенный в браузер объект, который даёт возможность делать HTTP-запросы к серверу без перезагрузки страницы.

Несмотря на наличие слова `XML` в названии, `XMLHttpRequest` может работать с любыми данными, а не только с `XML`. Мы можем загружать/скачивать файлы, отслеживать прогресс и многое другое.

### _Основы_

`XMLHttpRequest` имеет два режима работы: `синхронный` и `асинхронный`.

Чтобы сделать `асинхронный` запрос, нам нужно выполнить три шага:

1. Создать `объект` запроса `XMLHttpRequest`
``` 
let xhr = new XMLHttpRequest(); 
/=/ Конструктор не принимает аргументов
```
___
2. Инициализировать и `конфигурировать` `соединение`.
``` 
xhr.open(method, URL, [async, user, password])
```

Вызов `open`, вопреки своему названию, не открывает соединение. Он лишь `конфигурирует` запрос, но непосредственно отсылается запрос только лишь после вызова `send`.

- `method` – HTTP-метод. Обычно это `GET` или `POST`.
- `URL` – куда отправляется запрос: `строка`, может быть и `объект URL`.
- `async` – если указать `false`, тогда запрос будет выполнен `синхронно`.
- `user`, `password` – логин и пароль для базовой `HTTP-авторизации` (если требуется).

___
3. Установить соединение и послать запрос.
```
xhr.send([body])
```

Необязательный параметр `body` содержит тело запроса. 
Некоторые типы запросов, такие как `GET`, не имеют тела. А некоторые, как, например, `POST`, используют `body`, чтобы отправлять `данные на сервер`. 

___
4. Слушать события на `xhr`, чтобы получить ответ.
   
	**_! Слушатель необходимо добавлять перед отправкой `send()`_**

Три наиболее используемых события:
- `load` – происходит, когда `получен` какой-либо `ответ`(включая ответы с `HTTP-ошибкой`, например `404`).
- `error` – когда запрос не может быть выполнен, например, `нет соединения` или `невалидный URL`.
- `progress` – происходит периодически во время `загрузки` ответа, сообщает о `прогрессе`.

```
const url = "https://jsonplaceholder.typicode.com/users";  
  
const xhr = new XMLHttpRequest();  
xhr.open("GET", url);  
  
xhr.onload = () => {  
  if (xhr.status === 200) {  
    const users = JSON.parse(xhr.response);  
    console.log(users);  
  }  
};  
	==/OR/==  
xhr.responseType = "json";  

xhr.onload = () => {  
  if (xhr.status >= 400) {  
		console.error(xhr.response);
  } else {  
    console.log(xhr.response);  
  }  
};  

xhr.send();
```

### _Реализация с Promise_

```
const requestURL = "https://jsonplaceholder.typicode.com/users";  
  
function sendRequest(method, url, body = null) {  
  return new Promise((resolve, reject) => {  
    const xhr = new XMLHttpRequest();  
  
    xhr.open(method, url);  
  
    xhr.responseType = "json";  
    xhr.setRequestHeader('Content-Type', 'application/json')  
    /=/ Явно указываем серверу формат в котором отправляем данные  
  
    xhr.onload = () => {  
      if (xhr.status >= 400) {  
        reject(xhr.response);  
      } else {  
        resolve(xhr.response);  
      }  
    };  
  
    xhr.onerror = () => {  
      reject(xhr.response);  
    };  
  
    // xhr.send(body); /=/ При отправке преобразуется в string. [object Object]  
    xhr.send(JSON.stringify(body));  
  });  
}  
  
// sendRequest("GET", requestURL)  
//   .then((data) => console.log(data))  
//   .catch((err) => console.log(err));  
  
const body = {  
  name: 'username',  
  age: 23  
}  
  
sendRequest("POST", requestURL, body)  
  .then((data) => console.log(data))  
  .catch((err) => console.log(err));
```

## _Fetch_

Метод `fetch()` позволяет получать данные по сети `асинхронно`.
Возвращает `Promise`.

```
let promise = fetch(url, [options])

const getAllTodoes = () => {
	fetch('https://jsonplaceholder.typicode.com/todos', {
	method: 'GET', /=/ GET, POST, DELETE...

	headers: { 'Content-Type': 'application/json' } 
  /=/ При `post` указываем серверу формат в котором отправляем данные
})
```

Без `options` это простой `GET-запрос`, скачивающий содержимое по адресу `url`.

```
const requestURL = "https://jsonplaceholder.typicode.com/users";  
  
function sendRequest(method, url, body = null) {  
  const headers = {  
    'Content-Type': 'application/json'  
  }  
  
  return fetch(url, {  
    method: method,  
    body: JSON.stringify(body), /=/ При `post` конвертируем объект в JSON  
                                   (иначе будет [object Object])    
    headers: headers  
  })  /=/ Возвращает Promise  
    .then(response => {  
      if (response.ok) {  
        return response.json() /=/ Встроенный метод конвертации ответа в JSON  
      }  
      
      return response.json().then(error => {  
        const err = new Error('Что-то пошло не так')  
        err.data = error  
        throw err  
      })  
    })  
}

// sendRequest("GET", requestURL)  
//   .then((data) => console.log(data))  
//   .catch((err) => console.log(err));  
  
const body = {  
  name: 'username',  
  age: 23  
}  
  
sendRequest("POST", requestURL, body)  
  .then((data) => console.log(data))  
  .catch((err) => console.log(err));
```

___

```
const getAllTodoes = () => {
	fetch('https://jsonplaceholder.typicode.com/todos', {
	method: 'GET', /=/ GET, POST, DELETE..
})
	.then((responseValue) => {
		if (!responseValue.ok) { /=/ Eсли HTTP-статус в диапазоне 200-299
			/=/ ok - произошел ли запрос успешно
			throw new Error('Ошибка запроса');
			/=/ throw - выбрасывает ошибку и переводит в блок .catch()
		}
		return responseValue.json();
		/=/ Декодирование запроса
	})
	.then((todoes) => {
		/=/ Передаем дальше декодированный запрос
		todoes.forEach((el, i, arr) => {
			const todoHTML = createTodoElement(el.title);
			dataContainer.append(todoHTML);
		});
	})
	.catch((error) => {
		console.log('error:', error);
	})
	.finally(() => {
		toggleLoader();
	})
};
getAllTodoes()
```

## _Коды ответа HTTP_

Код ответа (`состояния`) HTTP показывает, был ли успешно выполнен определённый HTTP запрос. Коды сгруппированы в 5 классов:

1. `Информационные:` `100 - 199`
2. `Успешные:` `200 - 299`
3. `Перенаправления:` `300 - 399`
4. `Клиентские ошибки:` `400 - 499`
5. `Серверные ошибки:` `500 - 599`
