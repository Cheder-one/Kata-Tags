В соответствии с объектной моделью документа («`Document Object Model`», коротко `DOM`), каждый `HTML-тег` является `объектом`. Вложенные `теги` являются «детьми» родительского элемента. `Текст`, который находится внутри тега, также является `объектом`.

Все эти `объекты` доступны при помощи JavaScript, мы можем использовать их для изменения страницы. Например, `document.body` – объект для тега `<body>`.

## _Узлы HTML_

```
<!DOCTYPE HTML>
<html>
<head>
  <title>О лосях</title>
</head>
<body>
  Правда о лосях.
</body>
</html>
```

- Каждый `узел` этого дерева – это `объект`.

- `Теги` являются _`узлами-элементами`_ (или просто `элементами`). Они образуют `структуру` дерева: `<html>` – это корневой узел, `<head>` и `<body>` его дочерние узлы и т.д.

- `Текст` внутри `элементов` образует _`текстовые узлы`_, обозначенные как `#text`.
  `Текстовый узел` содержит в себе _только строку текста_. У него _не может быть потомков_, т.е. он находится всегда на самом нижнем уровне.

`Пробелы` и `переводы строки` – это полноправные символы, как буквы и цифры. Они образуют `текстовые узлы` и становятся частью дерева `DOM`.
Так, в примере выше в теге `<head>` есть несколько пробелов перед `<title>`, которые образуют текстовый узел `#text`.

![[Pasted image 20231103145025.png]]

1. По историческим причинам `пробелы` и перевод строки перед тегом `<head>` `игнорируются.`
2. Если мы записываем что-либо после закрывающего тега `</body>`, браузер автоматически перемещает эту запись в конец `body`.

Здесь `пробельных текстовых` узлов нет:

```markup
<!DOCTYPE HTML>
<html><head><title>О лосях</title></head><body>Правда о лосях.</body></html>
```

---

Все, что есть в `HTML`, даже `комментарии`, является частью `DOM`.

4 основных типа узлов:

1. `document` – «входная точка» в DOM.
2. `узлы-элементы` – HTML-теги, основные строительные блоки.
3. `текстовые узлы` – содержат текст.
4. `комментарии` – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.

---

## _Методы получения узлов и элементов_

### _Получить элемент `после` div_

- `li.nextSibling` - вернет следующий узел после указанного `li`. И вероятнее всего следующим узлом будет `#text` (`пробел`, `перенос`)
- `li.nextElementSibling` - вернет следующий `элемент` после `li`.

![[Pasted image 20231103151316.png]]

### _Получить `первый` элемент в div_

- `li.firstChild` - вернет первый `узел` внутри `родителя`. (который вероятнее всего будет `текстовым узлом`)
- `li.firstElementChild` - вернет первый вложенный `элемент` внутри указанного `родителя`

![[Pasted image 20231103152403.png]]

### _Получить `родителя` div_

- `div.parentElement` вернет `родительский элемент` элемента `div`.
- `div.parentNode` вернет `родительский узел` элемента `div`, включая `текстовые узлы` и `комментарии`, и `элементы`.

### _Получить `ближайшего родителя` div_

Свойство `.closest` используется для поиска ближайшего родительского элемента, соответствующего заданному селектору. Оно начинает `поиск` с текущего элемента и продолжает `вверх` по `DOM-дереву`.

```
<div class="parent">
  <div class="child">
    <span class="target">Целевой элемент</span>
  </div>
</div>
```

```
const targetElement = document.querySelector('.target'); const parentElement = targetElement.closest('.parent');
```

### _classList_

![[_.classList._]]

### _Атрибуты_

![[_.getAttribute()]]

## _Типы коллекций HTML_

![[_.children]]

## _Манипуляция элементами_

### _.appendChild()_

![[_.appendChild()]]

### _.insertAdjacentElement()_

![[_.insertAdjacentElement()]]

### _Правильное добавление элементов_

![[_.createDocumentFragment()]]

### _Удаление элементов_

```
title.remove()
title.parentElement.removeChild(title) /=/ Более старый метод
```

#удаление_DOM-элементов

## _События_

![[_.addEventListener()]]

### _Event. Делегирование событий_

![[event & bubbling]]


## _Коды ответа HTTP_

Код ответа (состояния) HTTP показывает, был ли успешно выполнен определённый HTTP запрос. Коды сгруппированы в 5 классов:

1. Информационные 100 - 199
2. Успешные 200 - 299
3. Перенаправления 300 - 399
4. Клиентские ошибки 400 - 499
5. Серверные ошибки 500 - 599
