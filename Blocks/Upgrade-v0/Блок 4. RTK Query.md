**RTK Query** - это об работе с `API`, `получать/изменять данные`, выполнять `CRUD` операции.
Все `взаимодействие с состоянием` переносится на `backend`. То есть мы `не копируем состояние с бэка на фронт`, а только `постоянно получаем данные с бэкенда`.  

## _createApi_

```
|> todosApi.ts
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

export const todosApi = createApi({
  reducerPath: "todosApi",
  tagTypes: ["Todos"],
  baseQuery: fetchBaseQuery({ baseUrl: "http://localhost:3001" }),
  endpoints: (build) => ({
    getTodos: build.query({
      query: ({ _limit }) => ({
        url: "/todos",
        params: { _limit },
      }),
      providesTags: ["Todos"],
    }),

    addTodo: build.mutation({
      query: (todo) => ({
        url: "/todos",
        method: "POST",
        body: todo,
      }),
      invalidatesTags: ["Todos"],
    }),

    updateTodo: build.mutation({
      query: ({ id, ...todo }) => ({
        url: `/todos/${id}`,
        method: "PATCH",
        body: todo,
      }),
      invalidatesTags: ["Todos"],
    }),

    deleteTodo: build.mutation({
      query: (id) => ({
        url: `/todos/${id}`,
        method: "DELETE",
      }),
      invalidatesTags: ["Todos"],
    }),
  }),
});

export const {
  useGetTodosQuery,
  useAddTodoMutation,
  useUpdateTodoMutation,
  useDeleteTodoMutation,
} = todosApi;
```

```
|> store.ts
import { configureStore } from "@reduxjs/toolkit";
import { todosApi } from "./todosApi";

export const store = configureStore({
  reducer: {
    [todosApi.reducerPath]: todosApi.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(todosApi.middleware),
});

/=/ goodsApi.reducerPath используется в качестве динамического ключа
/=/ goodsApi.reducer присваивается этому свойству.
/=/ middleware - логика которая выполняется в момент запуска actions, до их выполнения.
```

```
|> App.tsx
import { useGetTodosQuery } from "./redux/todosApi";

export type Todo = {
  userId: number;
  id: number;
  title: string;
  completed: boolean;
};

export type Response = {
  data: Todo[];
  error: string;
  isLoading: boolean;
};

const App = () => {
	const { data, isLoading } = useGetTodosQuery<Response>({ _limit: 10 });
  /=/ Инициализирует запрос к серверу https://.../todos
	const [addTodo, { isError: isAddError }] = useAddTodoMutation();
	/=/ Делает запрос по необходимости

  return data?.map((todo) => (
    <p key={todo.id}>
      <label>
        <input type="checkbox" defaultChecked={todo.completed} />
        {todo.title}
      </label>
    </p>
  ));
};

export default App;


```

## _Кеширивание тегов_

### _Инвалидация_

**Инвалидация** - означает `пометку данных в кеше как устаревших или недействительных`. Когда `данные инвалидируются, это означает`, что они не отражают текущее состояние на сервере и `нуждаются в обновлении`.

Когда `данные на сервере изменяются` (например, при обновлении или удалении), важно `уведомить локальный кеш` о том, что `сохраненные данные стали устаревшими`.

Пример:
1. **Начальное состояние:**
    - Вы загружаете список уведомлений с сервера и кешируете их локально.
2. **Изменение на сервере:**
    - На сервере происходит изменение или удаление одного из уведомлений.
3. **Инвалидация кеша:**
    - Система инвалидации кеша помечает кеш для уведомлений, которые были изменены или удалены, как устаревший.
4. **Получение свежих данных:**
    - Когда пользователь запрашивает данные, связанные с уведомлением, система обнаруживает, что кеш устарел, и отправляет запрос на сервер для получения актуальных данных.

