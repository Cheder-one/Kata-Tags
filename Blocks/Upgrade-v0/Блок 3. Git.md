### _Delete brunch удаленно + локально_
```
git push origin --delete branch_name /=/ Remote
git fetch --prune /=/ Удалить локальные ссылки на удаленные ветки
git branch -d branch_name /=/ Local
```

### _Push all new data from the main branch_

```
git checkout your_branch_name
git merge main
git push origin your_branch_name
```

This will switch to your branch, merge in the changes from the main branch, and then push the changes to your remote repository.

### _Git без посторонних файлов_

```
git checkout main /home/username/Docs/.../landing/Landing.tsx
```

Проверяйте то, что собираетесь закоммитить и отправить в репозиторий, не допускайте попадания посторонних файлов, в которых вы не работали, особенно это касается package.json и package-lock.json, в том случае, если вы самостоятельно не устанавливали дополнительный npm пакет в проект, если же вы допустили попадания лишних файлов в репозиторий, то находясь на своей ветке в своём редакторе кода, необходимо прописать` git checkout main "абсолютный путь до того файла, который нужно откатить"`, далее коммитите и отправляете в репозиторий уже те файлы, которые нужны.

## _merge_

-> Смерджить ветку `main` в ветку `bugFix`
```
git checkout bugFix
git merge main 
```

-> Слияние `bugFix` с веткой `main`
```
git checkout main
git merge bugFix 
```

## _rebase_

Второй способ `объединения изменений в ветках` - это `rebase`. При ребейзе Git по сути `копирует набор коммитов и переносит их в другое место`.

Преимущество `rebase` в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете `rebase`.

-> `rebase bugFix на main` 
```
git checkout bugFix
git rebase main
```

## _HEAD_

**HEAD** - это `указатель` на `выбранную ветку или коммит`. 
Это `указатель` на текущую ветку в вашем репозитории. Он обычно указывает на последний коммит в текущей ветке.

```
git checkout bugFix /=/ HEAD последует за переключением на branch
```

## _Detached HEAD_

**Detached HEAD** - это состояние, когда `HEAD` указывает `на определённый коммит`, `а не на какую-либо ветку`.

`Detached HEAD` используется, например, для просмотра истории коммитов, выполнения экспериментов, или выполнения операций над конкретным коммитом без создания новой ветки.

```
git log
git checkout 52346ad2 /=/ HEAD последует за переключением на commit
```

Например, если вы хотите проверить работу приложения на определенном коммите, вы можете использовать `git checkout <commit_hash>` для переключения в "detached HEAD" состояние и протестировать приложение на этом конкретном коммите.

### _HEAD^_

Относительные ссылки:
- Перемещение на один коммит назад `^`
- Перемещение на несколько коммитов назад `~<num>`

```
git checkout bugFix
git checkout HEAD^
git checkout HEAD^
git checkout HEAD^ /=/ Переместит указатель на 3 коммита назад
```

### _Перемещение ветки (branch -f)_

 **Branch forcing** - это процесс, при котором вы перезаписываете историю коммитов в удаленной ветке. 
 
Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую `прикрепить ветку к коммиту` при помощи опции `-f`. 

! Внимание !
! Это может повлечь за собой потерю истории коммитов и создание конфликтов у других разработчиков, работающих с веткой `main`

```
git branch -f main HEAD~3 
```

Перемещает ветку `main` на три коммита назад от текущего положения HEAD, что позволяет выполнить откат изменений.

## _reset/revert изменений_

### _git reset_

**git reset** - локально отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "`локальное переписывание истории`"; 

**Reset** `работает на локальных ветках`, в `локальных репозиториях`, но этот метод переписывания истории `не сработает на remoute ветках`, которые используют другие пользователи.

```
git reset HEAD~1
/=/ Отменяет последний коммит
/=/ Изменения, которые были в последнем коммите, остаются в истории коммитов, но становятся "незакоммиченными".
```

### _git revert_

**git revert** - `отменить remoute изменения` и поделиться отменёнными изменениями с остальными.

```
git revert HEAD
```

Появится новый коммит. Дело в том, что `новый коммит` `C2'` просто `содержит изменения, полностью противоположные` тем, что сделаны в коммите `C2`.

После `revert` можно сделать `push` и поделиться изменениями с остальными.

## _cherry-pick_

Теперь речь пойдёт о перемещении изменений — возможности, позволяющей разработчику сказать "Хочу, чтобы эти изменения были вот тут, а вот эти — вон там" и получить точные, правильные результаты, не теряя при этом гибкости разработки.

Это очень простой и прямолинейный способ сказать, что ты хочешь` копировать несколько коммитов на место, где сейчас находишься`(`HEAD`).

Есть некие изменения(`commit'ы`) в ветке `side`, мы хотим применить их так же в ветку `main`. 
![[Pasted image 20240211223618.png]]

```
git checkout main
git cherry-pick C2 C4
```

Перенесли коммиты `C2` и `C4` из ветки `side` в `main`
![[Pasted image 20240211224539.png]]

## _rebase -i_

`cherry-pick` удобен когда точно известно какие коммиты нужны и известны их точные хеши. Но как быть в случае, когда `точно не известно какие коммиты нужны`? 

Можно использовать` интерактивный rebase` для этого - лучший способ `отобрать набор коммитов для rebase`. Всё, что нужно для интерактивного rebase - это опция `-i`

Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.

После открытия окна интерактивного rebase есть три варианта для каждого коммита:
- Можно `сменить положение коммита по порядку`, переставив строчку с ним в редакторе.
- Можно `выкинуть коммит из ребейза`. Для этого есть `pick` - переключение его означает, что нужно выкинуть коммит.
- Наконец, можно `соединить коммиты`. При помощи этой функции можно объединять изменения двух коммитов.

```
git rebase -i HEAD~4
```

-> Пример: Мы хотим добавить в `main` только исправление ошибки из ветки `bugFix`.
```

```