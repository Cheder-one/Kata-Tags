
JavaScript имеет слабую динамическая типизацию. 

- `Динамическая типизация` — у нас есть `переменная` например `с числом`, но` в рантайме` мы можем `изменить её на строку` (или любой другой тип). 
- `Слабая типизация` — у нас есть `2 переменные (с числом и строкой)`, при их `сложении` результат `приведется к строке`.

## _Примитивные примеры_

```
const sum = (a: number, b: number): string => {
	return String(a + b);
};

const n1: 40 = 40; /=/ Можем задавать тип как "фиксированное значение"
const n2: number = 2;

console.log(sum(n1, n2));

```

```
/=/ Простые типы:
let str: string = "Hello";
let num: number = 10;
let bool: boolean = true;
let nul: null = null;
let und: undefined = undefined;

/=/ Массивы:
let arr1: number[] = [1, 2, 3];
let arr2: string[] = ["a", "b", "c"];
let arr3: boolean[] = [true, false, true];

/=/ Объекты:
let obj1: { name: string, age: number } = { name: "John", age: 30 };
let obj2: { [key: string]: number } = { one: 1, two: 2, three: 3 };

/=/ Функции:
function add(a: number, b: number): number {
  return a + b;
}
function doSomething(f: Function) {
  return f(1, 2, 3);
}
function doSomething(): void {
	// код функции
}

/=/ Перечисления:
enum Color {
  Red = 'red',
  Green = 'green',
  Blue = 'blue'
}

let color: Color = Color.Red;
console.log(color); /=/ Выведет 'red'
```

## _any_

- Тип `any` - подразумевает любое значение
- Тип `object` - аналогичен `any`, но только для объектов. Это `объект с любыми полями`, который `не равняется null

```
JSON.parce() /=/ Указывает что возвращает any

parse(text: string, reviver?: (
	(this: any, key: string, value: any) => any) | undefined): any
```

```
let x: number = JSON.parce('6')
let str: string = JSON.parce('sdfaf')
```

## _enum (перечисления)_

Перечисления `облегчают работу` с наборами `константных значений`, делая код более `читаемым и понятным`.

```
 enum Direction {
  Up,   // 0
  Down, // 1
  Left, // 2
  Right // 3
}

let dir: Direction = Direction.Up;

if (dir === Direction.Up) {
  console.log("Go up!");
} else if (dir === Direction.Down) {
  console.log("Go down!");
} else if (dir === Direction.Left) {
  console.log("Go left!");
} else if (dir === Direction.Right) {
  console.log("Go right!");
}
```

```
enum Color {
  Red = 'red',
  Green = 'green',
  Blue = 'blue'
}

let color: Color = Color.Red;
console.log(color); /=/ Выведет 'red'
```

## _union - составной тип_

```
/=/ Используем pipe-оператор "|"
let score: number | string  

const arr4: (string | number)[] = [1, '2', 3]
const arr5: Array<string | number> = [1, '2', 3]
```

## _type Alias составного типа_

При частом использовании `составного типа`, ему задают `псевдоним` 

```
type Score = number | string 
let score: Score = 7

type PipeType = (string | number)
const array: PipeType[]= []

type PipeTypeArr = Array<string | number>
const array: PipeTypeArr = []
```

## _Типизация массивов и объектов_

### _Массивы_

- Списки - Все `элементы` имеют `один тип`, `любая длинна массива`
```
-> const arr: number[] 
const arr = [1, 2, 3] 
const arr2: number[] = [1, 2, 3] 
const arr3: Array<number> = [1, 2, 3] 

const arr4: string[][] = [['a', 'b'], ['c', 'd']]
            элемент контейнер
```
  
- Кортежи (`tuple`) - Может содержать `элементы разного типа`, `фиксированная длинная`
```
const tuple1: [string, number, boolean] = ["2", 1, true];

type UserTuple = [string, number, boolean];
const user: UserTuple[] = [["Pipa", 18, true]];
```

### _Объекты_

! Внимание !
! При создании `interface` необходимо начинать его имя с `I`.
Это позволяет `избежать пересечений имен` интерфейсов с библиотечными их мутирования.

Или использовать `type`, он не позволяет создавать 2 одинаковых имени.

```
type User = {
  a: number;
  b: string;
  c: Function; /=/ Но лучше более конкретно: () => boolean
};

interface IUser {
  readonly a: number; /=/ Запрещено изменять
  b: string;
  c?: () => boolean; /=/ Опциональный ключ имеет тип (func | undefined)
  
  [key: string]: string | number | Function | undefined; /=/ Индексный тип
	/=/ Дает возможность добавлять доп свойства в объект, помимо указанных
}

const obj: IUser = {
  a: 1,
  b: "2",
  // c: () => true,
  d: 3,
};

// obj.a = 2; /=/ error
```

### _Индексный тип_

-> `Работает`
```
interface IPerson {
  age: number;
  name: string;
  [key: string]: number | string;
}
```

-> `Не сработает`
```
interface IPerson {
  age: number;
  name: string;
  [key: string]: string; /=/ Не учитывает тип number у key:age
}
```

### _Объединение типов_

```
type T = "a" | "b" | "c";

let x: T = "a";
x = "b";
x = "c";
// x = "v" /=/ error
```

-> `Должно присутствовать 'a' И/ИЛИ 'b'`
```
type T = { a: string } | { b: string };

let obj: T = { a: "" };
obj = { b: "" };
obj = { a: "", b: "" };
// obj = { a: "", b: "", c: "" }; /=/ error
// obj = {}; /=/ error
```

### _Пересечение типов_
**Intersection Types '`&`'**  используется `для создания объединенных типов`

-> `Должно присутствовать И 'a' И 'b'`
```
type T = { a: string } & { b: string };

let obj: T = { a: "", b: "" };
// obj = {}; /=/ error
// obj ={ a: "" }; /=/ error
// obj = { b: "" }; /=/ error
// obj = { a: "", b: "", c: "" }; /=/ error
```

```
type A = { foo: number };
type B = { bar: string };
type C = { baz?: string };

/=/ Тип D содержит обязательные свойства foo и bar
/=/ И необязательное свойство baz
type D = A & B & C;

const obj: D = {
  foo: 42,
  bar: "Hello",
};
```

### _Наследование  интерфейсов_
**Наследование '`extends`'** используется для наследования в интерфейсах.

```
interface Animal {
  name: string;
}

interface Dog extends Animal {
  breed: string;
}

interface Cat extends Animal {
  color: string;
}

```

### _Пересечение интерфейсов_

- При создании `interface` необходимо начинать его имя с `I`, дабы избежать мутирований.
- Или использовать `type`, он не позволяет создавать 2 одинаковых имени.

```
interface Person {
  firstName: string;
}
interface Person {
  lastName: string;
}

const person: Person = {
  firstName: "John",
  lastName: "Doe",
};
/=/ Произошло пересечение двух интерфейсов
```

```
type Person = {
  firstName: string;
}
// type Person = {  /=/ Повторяющийся идентификатор "Person"
//   lastName: string;
// }

const person: Person = {
  firstName: "John",
  // lastName: "Doe",
};
```

## _Приведение типов_

```

```

## _Generics_

```
function identity<T>(arg: T): T {
  return arg;
}

const result = identity<number>(42);
console.log(result); /=/ Output: 42
```

В этом примере мы используем `Generics`, чтобы создать `универсальную функцию` `identity`.

`<T>` в `определении функции` означает, что мы `создаем универсальную функцию`, которая может принимать аргумент любого типа. 
Тип `T` является` параметром типа`, который `позволяет` нам `переиспользовать одну и ту же функцию` с `разными типами данных`.

Функция принимает аргумент типа `T` и возвращает аргумент того же типа. 
Затем мы вызываем `identity<number>(42)`, чтобы указать, что `T` должен быть типа `number`, и сохраняем результат в переменную `result`.

-> `Если нужно чтобы функция возвращала отличное от generic значение`
```
function identity<T>(arg: T): string {
  return arg.toString();
}

const result = identity<number>(42);
console.log(result); /=/ Output: '42'
```

## _Явная/неявная типизация_

-> `Явная типизация (неуместна здесь)`
```
let message: { text: string } = { text: "hello!" };
console.log(message.text.toUpperCase());
```

-> `Неявная типизация`  
```
const message = { text: "hello!" };
console.log(message.text.toUpperCase());

/=/ TS сам определил что: '(property) text: string'
```

-> `Неявная типизация. Установка литерала как типа через const`
```
const message = '123'       /=/ const message: "123" 
const count = 4             /=/ Всегда равно 4
const isPermitted = false   /=/ Всегда равно false
const user = null           /=/ Всегда равно null
const book = undefined      /=/ Всегда равно undefined

Явная типизация. Установка литерала 
const count: 2 = 2          /=/ Всегда равно 2
```

-> `Неявная типизация значения, без присваивания значения как типа`
```
const product = { name: 'Phone' } /=/ const product: { name: string }
const doNothing = function() {} /=/ const doNothing: () => void
```

## _Когда нужна аннотация типов_

- Когда функция возвращает тип `any` и нам нужно уточнить что она возвращает 
```
let x: number = JSON.parce('6')
```
- Когда объявление переменной и присвоение ей значения происходит на разных строчках
```
let isOdd: boolean;

if (x % 2 === 0) {
  isOdd = false;
} else {
  isOdd = true;
}
```
- Если мы не хотим чтобы TS назначал тип за нас
```
 /=/ Неявно типизирует: "let score: number"
let score = 10

/=/ Явно типизируем, указывая, что тип может меняться
let score: number | string = 10 
```

## _tsconfig_

![[tsconfig]]
