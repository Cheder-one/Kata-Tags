
JavaScript имеет слабую динамическая типизацию. 

- `Динамическая типизация` — у нас есть `переменная` например `с числом`, но` в рантайме` мы можем `изменить её на строку` (или любой другой тип). 
- `Слабая типизация` — у нас есть `2 переменные (с числом и строкой)`, при их `сложении` результат `приведется к строке`.

## _Примитивные примеры_

```
/=/ Простые типы:
let str: string = "Hello";
let num: number = 10;
let bool: boolean = true;
let nul: null = null;
let und: undefined = undefined;
____________________________________________________________________________________
/=/ Массивы:
let arr1: number[] = [1, 2, 3];
let arr2: string[] = ["a", "b", "c"];
let arr3: boolean[] = [true, false, true];
____________________________________________________________________________________
/=/ Объекты:
let obj1: { name: string, age: number } = { name: "John", age: 30 };
let obj2: { [key: string]: number } = { one: 1, two: 2, three: 3 };
____________________________________________________________________________________
/=/ Функции:
function sum(a: number, b: number): number {
  return a + b;
}

function doSomething(f: Cb) {
  return f(1, 2, 3);
}
type Cb = (num: number) => number

const getCourses: Func = (page, search) => {
	return {};
};
type Func = (page: number, search?: string) => {};

function fn([num, str, bool]: Args) {
  console.log(num, str, bool);
}
type Args = [number, string, boolean];
____________________________________________________________________________________
/=/ Перечисления:
enum Color {
  Red = 'red',
  Green = 'green',
  Blue = 'blue'
}

let color: Color = Color.Red;
console.log(color); /=/ Выведет 'red'
```

## _Явная/неявная типизация_

-> `Явная типизация (неуместна здесь)`
```
let message: { text: string } = { text: "hello!" };
console.log(message.text.toUpperCase());
```

-> `Неявная типизация`  
```
const message = { text: "hello!" };
console.log(message.text.toUpperCase());

/=/ TS сам определил что: '(property) text: string'
```

-> `Неявная типизация. Установка литерала как типа через const`
```
const message = '123'       /=/ const message: "123" 
const count = 4             /=/ Всегда равно 4
const isPermitted = false   /=/ Всегда равно false
const user = null           /=/ Всегда равно null
const book = undefined      /=/ Всегда равно undefined

Явная типизация. Установка литерала 
const count: 2 = 2          /=/ Всегда равно 2
```

-> `Неявная типизация значения, без присваивания значения как типа`
```
const product = { name: 'Phone' } /=/ const product: { name: string }
const doNothing = function() {} /=/ const doNothing: () => void
```

## _Когда нужна аннотация типов_

- Когда функция возвращает тип `any` и нам нужно уточнить что она возвращает 
```
let x: number = JSON.parce('6')
```
- Когда объявление переменной и присвоение ей значения происходит на разных строчках
```
let isOdd: boolean;

if (x % 2 === 0) {
  isOdd = false;
} else {
  isOdd = true;
}
```
- Если мы не хотим чтобы TS назначал тип за нас
```
 /=/ Неявно типизирует: "let score: number"
let score = 10

/=/ Явно типизируем, указывая, что тип может меняться
let score: number | string = 10 
```

## _any_

- Тип `any` - подразумевает любое значение
- Тип `object` - аналогичен `any`, но только для объектов. Это `объект с любыми полями`, который `не равняется null

```
JSON.parce() /=/ Указывает что возвращает any

parse(text: string, reviver?: (
	(this: any, key: string, value: any) => any) | undefined): any
```

```
let x: number = JSON.parce('6')
let str: string = JSON.parce('sdfaf')
```

### _unknown  vs  any_

- `any`: тип `any` представляет `отсутствие статической типизации`. 
  Когда переменной присваивается тип `any`, это означает, что `компилятор TypeScript не будет проверять типы` данных во время компиляции.
- `unknown`: тип `unknown` также представляет `неизвестный тип данных, но с более строгим ограничением`.
  Переменная типа `unknown` `не может быть присвоена или использована напрямую без явного приведения типа или проверки типа`. 

Когда тип переменной объявлен как `unknown`, вы можете присвоить ей значения любого типа без ошибки компиляции. Однако, при попытке использования переменной с типом `unknown`, вы будете ограничены в операциях, которые можете выполнить без явного приведения типов или проверки типа.

```
let x: unknown;
x = 10;
x = "hello";

const sum = x + 10 /=/ error. "x" относится к типу unknown
x.toString(); /=/ error. "x" относится к типу unknown

console.log(x); /=/ "hello"
```

## _enum (перечисления)_

Перечисления `облегчают работу` с наборами `константных значений`, делая код более `читаемым и понятным`.

! Внимание !
! Использовать `только с реальными константами`, которые действительно `не поменяются` (`что-то вроде времен года`)


```
const enum Color {
  Red = 'red',
  Green = 'green',
  Blue = 'blue'
}

 function getColorName(color: Color): string {
  switch (color) {
    case Color.Red:
      return 'Красный';
    case Color.Green:
      return 'Зеленый';
    case Color.Blue:
      return 'Синий';
    default:
      return 'Неизвестный цвет';
  }
}

const color = Color.Green;
const colorName = getColorName(color);
console.log(colorName); /=/ выводит 'Зеленый'
```

## _union - составной тип "|"_

-> `Расширение типов`
```
/=/ Используем pipe-оператор "|"
let score: number | string  

const arr4: (string | number)[] = [1, '2', 3]
const arr5: Array<string | number> = [1, '2', 3]
```

## _type - аlias для составного типа_

При частом использовании `составного типа`, ему задают `псевдоним` 

```
type Score = number | string 
let score: Score = 7

type PipeType = (string | number)
const array: PipeType[]= []

type PipeTypeArr = Array<string | number>
const array: PipeTypeArr = []
```

## _Типизация массивов и объектов_

### _Массивы_

- Списки - Все `элементы` имеют `один тип`, `любая длинна массива`
```
-> const arr: number[] 
const arr = [1, 2, 3] 
const arr2: number[] = [1, 2, 3] 
const arr3: Array<number> = [1, 2, 3] 

const arr4: string[][] = [['a', 'b'], ['c', 'd']]
            элемент контейнер
```
  
- Кортежи (`tuple`) - Может содержать `элементы разного типа`, `фиксированная длинная`
```
const tuple1: [string, number, boolean] = ["2", 1, true];

type UserTuple = [string, number, boolean];
const user: UserTuple[] = [["Pipa", 18, true]];
```

### _Объекты_

! Внимание !
! При создании `interface` необходимо начинать его имя с `I`.
Это позволяет `избежать пересечений имен` интерфейсов с библиотечными их мутирования.

Или использовать `type`, он не позволяет создавать 2 одинаковых имени.

```
type User = {
  a: number;
  b: string;
  c: Function; /=/ Но лучше более конкретно: () => boolean
};

interface IUser {
  readonly a: number; /=/ Запрещено изменять
  b: string;
  c?: () => boolean; /=/ Опциональный ключ имеет тип (func | undefined)
  
  [key: string]: string | number | Function | undefined; /=/ Индексный тип
	/=/ Дает возможность добавлять доп свойства в объект, помимо указанных
}

const obj: IUser = {
  a: 1,
  b: "2",
  // c: () => true,
  d: 3,
};

// obj.a = 2; /=/ error
```

### _Индексный тип `[key: string]:`_

-> `Работает`
```
interface IPerson {
  age: number;
  name: string;
  [key: string]: number | string;
}
```

-> `Не сработает`
```
interface IPerson {
  age: number;
  name: string;
  [key: string]: string; /=/ Не учитывает тип number у key:age
}
```

### _Расширение типов "|"_

```
type T = "a" | "b" | "c";

let x: T = "a";
x = "b";
x = "c";
// x = "v" /=/ error
```

-> `Должно присутствовать 'a' И/ИЛИ 'b'`
```
type T = { a: string } | { b: string };

let obj: T = { a: "" };
obj = { b: "" };
obj = { a: "", b: "" };
// obj = { a: "", b: "", c: "" }; /=/ error
// obj = {}; /=/ error
```

```
let ages: Ages = ["12", "18", "9"];
ages = [22, 48, 100];

type Ages = string[] | number[];
```
### _Пересечение типов "&"_
**Intersection Types '`&`'**  используется `для создания объединенных типов`

-> `Должно присутствовать И 'a' И 'b'`
```
type T = { a: string } & { b: string };

let obj: T = { a: "", b: "" };
// obj = {}; /=/ error
// obj ={ a: "" }; /=/ error
// obj = { b: "" }; /=/ error
// obj = { a: "", b: "", c: "" }; /=/ error
```

```
type A = { foo: number };
type B = { bar: string };
type C = { baz?: string };

/=/ Тип D содержит обязательные свойства foo и bar
/=/ И необязательное свойство baz
type D = A & B & C;

const obj: D = {
  foo: 42,
  bar: "Hello",
};
```

### _Наследование  интерфейсов (extends)_
**Наследование '`extends`'** используется для наследования в интерфейсах.

```
interface Animal {
  name: string;
}

interface Dog extends Animal {
  breed: string;
}

interface Cat extends Animal {
  color: string;
}

```

### _Пересечение интерфейсов (слияние)_

- При создании `interface` необходимо начинать его имя с `I`, дабы избежать мутирований.
- Или использовать `type`, он не позволяет создавать 2 одинаковых имени.

```
interface Person {
  firstName: string;
}
interface Person {
  lastName: string;
}

const person: Person = {
  firstName: "John",
  lastName: "Doe",
};
/=/ Произошло пересечение двух интерфейсов
```

```
type Person = {
  firstName: string;
}
// type Person = {  /=/ Повторяющийся идентификатор "Person"
//   lastName: string;
// }

const person: Person = {
  firstName: "John",
  // lastName: "Doe",
};
```

## _Преобразование типов "as"_

**Преобразование типов** - это `обычный процесс типизации`, `который` просто `происходит` не динамически и неявно, а `вручную, более строго и явно`. Преобразование используется, когда `нужно изменить тип переменной`.

->  `Операции, которые требуют определенного типа данных`.
```
let str: string = "10";
let num: number = parseInt(str) as number; /=/ Преобразование строки в число

console.log(num === 10); /=/ true
```
___________________________________________________________________________
```
let x: any = {}; /=/ Небезопасный тип 'any' который на самом деле 'object'
let str: string = x; 

str + " hello"; /=/ '[object Object] hello' 
/=/ Должна быть ошибка, но ее нет
```

```
let x: unknown /=/ Безопасный тип
x = 10

let num: number = x /=/ Ошибка присваивания (разные типы)

let num: number = <number>x
let num: number = x as number
```

## _Сужение типов_

```
let id: string | number;

/=/ id.common_methods_for_string_and_number

const logId = (id: string | number) => {
  if (typeof id === "string") {   /=/ type-guard
    /=/  id.all_methods_for_string
  }
  if (typeof id === "number") {   /=/ type-guard
    /=/ id.all_methods_for_number
  } else {
		/=/ id.common_methods_for_string_and_number
  }
};
```

## _Type Guarg "is"_

**TypeGuard** - это `выражение или функция`, который `ограничивает поток` TS, указывая что `дальше будет определенный тип`.

Примеры `type guard`:
+ Выражение `typeof id === "number"`
+ Проверочная функция `isBackDev`(`пользовательская проверка данных`)

```
/=/ Class является самодекларирующимся и не нуждается в interface
class FrontDev {
  isCreateApi: boolean = false;
}

class BackDev {
  isCreateApi: boolean = true;
  createApi() {}
}

/=/ Функция isBackDev проверяет, является ли разработчик бэкендDev
const isBackDev = (developer: Developer): developer is BackDev => {
  return developer.isCreateApi;
};
/=/ Если true, то interface возвращаемого значения будет установлен как BackDev
/=/ Если false, то interface возвращаемого значения будет установлен как FrontDev
/=/ Это позволит получить доступ к соответствующим свойствам

type Developer = FrontDev | BackDev;

const writeCode = (developer: Developer): void => {
  if (developer.isCreateApi) {
    // developer.createApi(); /=/ error
  }
	/=/ Эта проверка не позволяет TS понять существует ли свойство в переданном типе
	/=/ Тк на вход поступает FrontDev | BackDev

  /=/ Используем пользовательскую проверку данных
  if (isBackDev(developer)) {
    developer.createApi();
  }
};
```

## _non-null оператор "!"_

```
let n1: number | null | undefined = null;

setTimeout(() => {
  n1 = 10;
}, 500);

setTimeout(() => {
  /=/ Значение может быть number | null | undefined
	const n2: number = n1; /=/ error
  
  /=/ Обещаем TS, что n1 не может быть null
  const n2: number = n1!; 
  console.log(n2); /=/ 10
}, 1000);
```

## _Функции_

```
type Func = (page: number, search?: string) => {};

const getCourses: Func = (page, search) => {
	return {};
};
```

### _Типизация callback-аргумента_
 
 ```
type Callback = (num: number) => string;

const fn2 = (cb?: Callback) => {
  if (cb) {
    const res = cb(10);
    console.log(res);
  }
  console.log("no callback");
};
```

### _Типизация через значения по-умолчанию_

```
const fn3 = (x = 0, y = 0) => {
  return [x, y];
};

/=/ Идентичная, но нечитабельная запись
const fn3 = (x?: number, y?: number): (number | undefined)[] => {
  return [x, y];
};
```

### _Типизация rest аргументов_

```
function fn4(...nums: number[]): string {
	return nums.join("-");
}
```

```
type Args = [number, string, boolean];

function fn(...args: Args) {
  const [num, str, bool] = args;
  console.log(num, str, bool);
}

function fn([num, str, bool]: Args) {
  console.log(num, str, bool);
}

fn(10, "Привет", true);
```

### _Особенности работы функций с объектами_

```
interface Printable {
  label: string;
}

const drink = {
  label: "tea",
  sugar: 10,
  color: "brown",
  carbonated: false,
};

function printReport(obj: Printable) {
  console.log(obj.label); /=/ Разрешено только типизированое поле
  // console.log(obj.sugar); /=/ error


printReport(drink); /=/ Ok

printReport({
  label: "tea",      /=/ Ok
  sugar: 10,         /=/ error
  color: "brown",    /=/ error
  carbonated: false, /=/ error
});
/=/ При передаче объекта напрямую - запретит передавать не типизированные поля
```

### _Перегрузка_

 **Перегрузка**(`overloading`) - это возможность определить несколько сигнатур 
 функции(`case`) с разными наборами параметров. 
 Когда вызывается функция или метод, TypeScript `выбирает подходящую перегрузку` на основе переданных аргументов.

- При использовании перегрузки, `кол-во аргументов` в кейсах `не должно меняться`
- Сколько `вариантов кейсов` было описано, `столько же ветвлений` должно быть задано внутри функции

```
const cards = [
  { id: 1, name: "card1" },
  { id: 2, name: "card2" },
];

type Card = { id: number; name: string };

function pickCard(x: number): Card;   /=/ 1
function pickCard(x: Card[]): number; /=/ 2

function pickCard(x: any): any {
  if (typeof x == "number") { /=/ 1
    return cards[x];
  }
  if (typeof x == "object") { /=/ 2
    return x[0].id;
  }
}
```
 
## _Generics_

```
function identity<T>(arg: T): T {
  return arg;
}

const result = identity<number>(42);
console.log(result); /=/ Output: 42
```

В этом примере мы используем `Generics`, чтобы создать `универсальную функцию` `identity`.

`<T>` в `определении функции` означает, что мы `создаем универсальную функцию`, которая может принимать аргумент любого типа. 
Тип `T` является` параметром типа`, который `позволяет` нам `переиспользовать одну и ту же функцию` с `разными типами данных`.

Функция принимает аргумент типа `T` и возвращает аргумент того же типа. 
Затем мы вызываем `identity<number>(42)`, чтобы указать, что `T` должен быть типа `number`, и сохраняем результат в переменную `result`.

-> `Если нужно чтобы функция возвращала отличное от generic значение`
```
function identity<T>(arg: T): string {
  return arg.toString();
}

const result = identity<number>(42);
console.log(result); /=/ Output: '42'
```

## _Interface vs Type_

- **Interface** - используется `для определения структуры объекта или класса`. 
  Для `доменной логики` проекта, `для объектов которые приходят к нам по API`
  (**классы, объекты, логика приложения**)
  
```
interface Person {
  name: string;
  age: number;
}

interface Employee extends Person {
  position: string;
}
```

- **Type** - используется для `объединения типов "|"`, `пересечение типов "&"` или использовать `типы, которые не являются объектами`. Для `взаимодействия с interface`
  (**поведенческие моменты**)

```
type ID = string | number;

type Point = {
  x: number;
  y: number;
};

type Employee = Person & {
  position: string;
};
```

## _Class implements_

Ключевое слово `implements` используется в TypeScript для указания, что `класс реализует` (`implement-тирует`) определенный `interface`. 

Когда `класс реализует интерфейс`, он `обязуется реализовать все методы и свойства`, определенные `в интерфейсе`. Больше чем в `interface` можно, меньше нельзя.

```
interface Animal {
  eat(): void;
  sleep(): void;
  talk?: void;
}

class Cat implements Animal {
  eat() {
    console.log("Cat is eating");
  }

  // sleep() {
  //   console.log("Cat is sleeping");
  // }

  run() {
    console.log("Cat is running");
  }
}

const cat = new Cat();
cat.eat();
// cat.sleep(); // error. Свойство "sleep" отсутствует в типе "Cat"
cat.run();
```

## _tsconfig_

![[tsconfig]]
