## _Web Technologies_

## _Прогрессивный рендеринг_

**Прогрессивный рендеринг** - для ускорения загрузки и отрисовки страницы.

Его цель - предоставить `минимальный и необходимый контент как можно быстрее`. 
А `затем дополнять` его `по мере продвижения`.

- **Lazy Loading** изображений
```
<img
	src="placeholder.jpg" /=/ Легкое изображение-заглушка
	data-src="image.jpg" /=/ Фактический источник изображения
	alt="Lazy-loaded image"
	loading="lazy"
>
```

- **Server-Side Rendering** - Сервер рендерит(выстраивает) HTML-страницу у себя и отправляет клиенту уже готовую. 
  Это освобождает клиента от затрат ресурсов на отрисовку.

## _Progressive Web Application (PWA)_

**PWA** - позволяет использовать `веб-сайт как нативное приложение` на разных платформах. 
- `Оффлайн` и `быстрая загрузка`, благодаря `кешированию` `Service worker's`
- Не нужно скачивать обновления, есть полная интеграция с устройством. 

**Service worker** - Это `фоновый скрипт`, не блокирующий основной поток выполнения кода. Способен `перехватывать запросы к серверу`, возвращая кеш при необходимости.

## _Кроссбраузерность_

**Кроссбраузерность** - Способность сайта `корректно отображаться` `в разных браузерах` и `в разных версиях`, а так же `на разных устройствах`.

- Верная `семантика тегов`

- Использование `reset / normalize`
- `Вендорные префиксы` браузеров и `Адаптивная верстка`

- Применение `Progressive Enhancement / Graceful Degradation`
- `Полифилы` для `поддержания функциональности`(`Babel`)

## _Модель OSI_

**Модель OSI** - состоит из `7 уровней абстракций` и `описывает как работает интернет`.

Каждый `слой имеет свой протокол` с правилами и `не знает о других слоях`, он просто делает свою работу

- Физический;
- Канальный;
- Сетевой;
- Транспортный;
- Сеансовый;
- Представления;
- Прикладной.

![[Pasted image 20240301164125.png]]

- Самый `нижний слой` отвечает за `физическую передачу` данных(`по проводам/радиоволнам`)
- Самый `верхний слой` за то `как приложение взаимодействует с сетью`. 
  Этот слой описывают протоколы:
	- `HTTP` (Hypertext Transfer Protocol) — самый популярный протокол для передачи данных по интернету.
	- `FTP` (File Transfer Protocol) — ещё один известный протокол, заточенный под передачу файлов. 
	- и тд

## _Поток документа_

**Поток документа** - `описывает поведение` того, `как элементы должны располагаться` на странице. 

- **Стандартный поток** документа формируют `блочные` и `строчные` типы элементов
- Изменить стандартный поток: `flex/grid/float`, `position`

## _Адаптивный vs Отзывчивый дизайн_

- **Адаптивный дизайн** - Имеет `несколько макетов для каждого устройства`. Используются `@media`.
- **Отзывчивый дизайн** - Имеет `1 макет для всех устройств`. 
  Использует `Flexbox` и `относительные единицы`(`rem, %`).

## _Progressive Enhancement vs Graceful Degradation_

Оба этих подхода `используются для поддержания кроссбраузерности и кроссплатформенности` сайта.

- **Progressive Enhancement** - От простого к сложному
- **Graceful Degradation** - Функционал деградирует от сложного к простому.

Предпочтительней использовать `Progressive Enhancement` т.к. он обеспечивает `более предсказуемый результат`.

## _Веб-компоненты_

**Веб-компоненты** - Позволяют создавать свои `переиспользуемые компоненты в виде HTML-тегов`. Они работают `напрямую браузером` и `без библиотек`.

## _RESTfull API_

- **REST** - `Aрхитектурный стиль`, 
- **RESTfull** - `Cервис` который `следует данной архитектуре`.
- **API** - `Интерфейс для взаимодействия с ресурсами` на сервере `через` указанные в документации `endpoint's`.

## _Концепция REST_

### _1. Клиент-серверная модель архитектуры_   

- **API** - `Сервер`
  Отвечает за `хранение данных` и `выполнение бизнес-логики`.
- **Клиент** - `Любое устройство`(`PC/mobile/server`)
  Отвечает за `визуализацию данных` и `взаимодействие с пользователем`.
  
Клиент-серверное `общение`, осуществляется `в виде запросов и ответов`.

### _2. Многоуровневость системы_

Клиент может `взаимодействовать с разными слоями сервера и не подозревать об этом`.

Сервер может иметь множество слоев с балансированием по другим серверам. 
Но `с точки зрения Клиента, система должна быть цельна`.

### _3. Отсутствие состояния_

При каждом запросе, `сервер и клиент общаются как в первый раз`. 

Для того чтобы `сервер идентифицировал` клиента и `понял что требуется сделать`,` клиент должен отправить вместе с запросом всю необходимую информацию`.

### _4. Единообразие интерфейса_

- Взаимодействие с ресурсами через `CRUD-операции`.
- Для каждого `ресурса существует свой путь`(`URL`) `для взаимодействия` с ним.

### _5. Кеширование_

Реализация кеширования запросов к серверу.

- Кеширование `GET` и `POST` запросов `через` проставление времени в `заголовки` `Cache-Control`.
- Не стоит кешировать `PUT` и `DELETE` запросы, тк они изменяют состояние сервера.

## _Критические этапы рендеринга_

**Critical Rendering Path** - Это `последовательность этапов`, которые выполняет браузер для того `чтобы преобразовать HTML, CSS и JS в конечное изображение` на экране.

![[Pasted image 20240301214536.png]]

- **Реализация** `DOM`(`Document Object Model`) на основе парсинга `HTML`.
- **Реализация** `CSSOM` на основе подключенных к документу стилей
- **Реализация** `JS` с возможной модификацией `DOM`.

- **Поиск** `a11y` атрибутов в `HTML`. Выстраивается `Accessibility Tree` для чтения `скринридерами`.

- **Объединение** `DOM + CSSOM` в `Render Tree`. В нем находится только видимое содержимое.
- **Расположение** элементов и расчет размеров (`Layout/Reflow`)
- **Покраска** элементов согласно заданным стилям (`Paint/Repaint`)

- **Позиционирование слоев**  элементов их `z-index` (`Compositing`)

## _render vs отрисовка_

- **Render** - Выстраивание `Render Tree`, объединяя `DOM CSSOM JS`.
- **Отрисовка** - Подразумевает окончание рендера, когда контент визуализировался на экране клиента. 

## _Событие DOMContentLoaded и load_

- **DOMContentLoaded** - Происходит когда `HTML полностью загружен`, `без ожидания` загрузки таблиц стилей, изображений и `внешний ресурсов`.
- **load** - Происходит `после полной загрузки всех ресурсов` страницы.

```
window.addEventListener('load', function() {
  /=/ Выполнится после полной загрузки всех ресурсов
});
```

## _Когда происходит Reflow и Repaint?_

- **Reflow(Пересчет)** - Происходит `при изменении геометрии элемента`(`изменение размеров` или `положения`). 
  Reflow `влечет за собой перерасчет` геометрии `всех остальных элементов`.
- **Repaint(Перерисовка)** - Касается только `визуальных изменений`(например, `background-color`). Не требует пересчета геометрии, менее затратен.

## _Flash Of Unstyled Content (FOUC)_

**Flash of Unsyled Content** - Вспышка нестилизованного контента. 
Это `появление неоформленного контента при загрузке`

- Размещать критический `CSS` в `<head>`
- Добавлять `Loader` или `Skeleton` до полной загрузки контента.

## _History API в браузере_

**History API** - позволяет `манипулировать историей браузера` с иcпользованием JS, через объект `window.history`.

## _Web Storage_

**Web Storage** - позволяет хранить данные пользователя в браузере.
- `cookie`
- `localStorage`
- `sessionStorage`

## _cookie/sessionStorage/localStorage_

|                 | cookie                     | sessionStorage      | localStorage  |
| --------------- | -------------------------- | ------------------- | ------------- |
| Инициатор       | Клиент/Сервер (Set-Cookie) | Клиент              | Клиент        |
| Срок хранения   | Установка вручную          | До закрытия вкладки | Не ограничено |
| Связь с доменом | Да                         | Нет                 | Нет           |
| Емкость         | 4 Kb                       | 5 Mb                | 5 Mb          |
| Доступность     | Любое окно                 | Только вкладка      | Любое окно    |

## _Как увеличить скорость загрузки страницы?_

- **Минификация** файлов(`удаление лишних пробелов и символов`) 
- **Объединение** файлов в один - это `уменьшит кол-во запросов`.
- **Сжатие** изображений.
- **Кеширование** ресурсов `через HTTP-заголовки`.
- **Использование CDN** для `использования данных с ближайшего сервера`.

## _Core Web Vitals_

**Core Web Vitals** - `метрики для оценки user-experience` при взаимодействии с сайтом.

- `Скорость загрузки наибольшего контента` на странице.
- `Задержку при взаимодействии`. 
- `Стабильность макета при загрузке` страницы.

## _Разница между preload, prefetch, preconnect и prerender?_

Данные свойства `используются` `в атрибуте` `rel` `для оптимизации загрузки` ресурсов.

1. **preload** - Загрузить `с высоким приоритетом и кешировать` ресурс. 
   Применение: Если ресурс может понадобиться через несколько секунд после загрузки страницы.
2. **prefetch** - Загрузить `в фоновом режиме, с низким приоритетом и кешировать`.
   Применение: Если ресурс понадобится на след. странице или в подменю.
3. **preconnect** - Заранее подключиться к домену
4. **prerender** - Загрузить и открыть `страницу в невидимой вкладке`, для моментального открытия.
   Применение: Если мы уверены что пользователь посетит эту страницу и хотим ускорить ее отображение.

![[Pasted image 20240302173226.png]]

## _Для чего нужен паттерн PRPL?_

**PRPL** - Описывает `4 этапа оптимизации при загрузке приложения`.

- **Push**(**Preload**) - Упор на `загрузку минимального контента для отображения`
  (`HTML, CSS, критический JS`)
- **Render** - После загрузки основного `контента`, приложение должно быть способно `быстро отобразить его на экране`. 
- **Pre-cache** - `Предварительное кеширование ресурсов`, которые `могут быть запрошены при дальнейших действия` пользователя.
- **Lazy-load** - Загрузка `некритических` ресурсов `асинхронно` или `по требованию`.

## _Разница между SSR и SSG и CSR?_

**SSR (Server-Side Rendering) и SSG (Static Site Generation)** - это `два подхода к генерации веб-страниц`.

**SSR (Server-Side Rendering):**
- **Как это работает:**
    - Сервер `генерирует HTML на сервере при каждом запросе` к странице.
    - Полная разметка страницы отправляется клиенту, включая данные.
- **Преимущества:**
    - Лучшая `SEO-оптимизация,` поскольку поисковые системы получают полностью сформированные страницы.
    - Лучшая `производительность для первой загрузки`, особенно на медленных устройствах или соединениях.
- **Недостатки:**
    - Больше `нагрузка на сервер`, так как каждый запрос требует повторной генерации страницы.
    - Б*о*льшая `задержка в интерактивности` на стороне клиента.

**SSG (Static Site Generation):**
- **Как это работает:**
    - Страницы `генерируются во время сборки` (`build time`) и сохраняются как статические файлы.
    - Клиентам отдается готовый HTML-контент.
- **Преимущества:**
    - Отличная `производительность`, так как `не требуется повторной генерации для каждого запроса`.
    - Возможность кэширования статических файлов на CDN.
- **Недостатки:**
    - `Обновление` данных может `потребовать пересборки сайта`.

**CSR (Client-Side Rendering):**
- **Как это работает:**
    - Исходный `HTML-код отправляется на клиент`, а затем браузер выполняет `JavaScript`, который `генерирует и вставляет контент`.
    - AJAX-запросы используются для получения данных после загрузки страницы.
- **Преимущества:**
    - `Быстрая интерактивность на стороне клиента` после первоначальной загрузки.
    - Удобство работы с динамическими данными.
- **Недостатки:**
    - `Проблемы с SEO`, так как поисковые системы могут иметь ограниченный доступ к динамическому контенту.
    - `Медленная первая загрузка`, особенно на медленных соединениях.

## _Babel_

**Babel** - инструмент для преобразования кода с одной версии на другую, для поддержания кроссбраузерности. Это позволяет использовать новейшие фичи языка.

## _feature detection/feature inference и user-agent_

`Feature detection`, `feature inference` и анализ строки `user-agent` - предназначены для `определения отдельных возможностей` браузера и `его характеристик`. 

- **Feature detection** - `Проверяет` наличие `отдельных функций и возможностей` в браузере. (наиболее надежный и современный метод)
```
if ('geolocation' in navigator) {
    /=/ Use navigator.geolocation
} else {
    /=/ Полифил заменяющий функционал
}
```
- **Feature interface** - `Предположение` о возможностях браузера,` на основе других возможностей`.
```
if (document.addEventListener) {
    /=/ Используем addEventListener, предполагая, что браузер современный
} else {
    /=/ Браузер устарел, используем attachEvent
}
```
- **User-Agent** - Заголовок `User-Agent` отправляется с каждым запросом на сервер. 
  Предоставляет информацию `о браузере`, `операционной системе` и тд
```
var userAgent = navigator.userAgent;

// "Mozilla/5.0 (X11; Linux x86_64; rv:123.0) Gecko/20100101 Firefox/123.0"
```

## _Что такое блокирующие и неблокирующие ресурсы?_

- **Блокирующие ресурсы** - `Необходимы при отображении страницы`, `блокируют парсер`. Выполнение `других частей кода будет приостановлено`, пока ресурс не загрузится.
	- Файл `CSS` в `<head>`
	- JS в теге `<script>`, без атрибута `async` или `defer`
- **Неблокирующие ресурсы** - Могут быть `загружены асинхронно`, `не блокируя парсер и процессы`. 
	- Загрузка изображения через тег `<img>`
	- Загрузка видео через тег `<video>`
	- Асинхронные `AJAX` запросы

## _Что такое GraphQL?_

**GraphQL** - `язык запросов` к API. Позволяет `запрашивать только те данные - которые нужны`.

- Получение `только запрашиваемых данных`
- Существует `единый endpoint` для всех запросов
- Лучше `производительность` API, за счет `уменьшения кол-ва запросов` и `объема передаваемых данных`.

```
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const client = new ApolloClient({
  uri: 'https://example.com/graphql', /=/ Замените на ваш реальный GraphQL endpoint
  cache: new InMemoryCache(),
});

/=/ Пример запроса
client
  .query({
    query: gql`
      query {
        user(id: 1) {
          id
          username
          email
        }
      }
    `,
  })
  .then(result => console.log(result));
```

Недостатки GraphQL:
- Сложность: GraphQL может быть сложным для понимания и использования, особенно для новичков.
- Кэширование: из-за гибкости GraphQL сложнее кэшировать запросы, что может привести к проблемам с производительностью.
- Уязвимость к DoS-атакам: из-за возможности запрашивать большое количество данных, GraphQL может быть уязвим к DoS-атакам.

## _Web API_

## _Что такое HTTP?_

**HTTP (HyperText Transfer Protocol)**  - Протокол для `передачи данных` в сети. 
Основное назначение - `обеспечение коммуникации между клиентом и сервером`. 

**HTTP** определяет то, `как клиент и сервер должны общаться`:
- **Методы запросов** `GET, POST, PUT, PATCH, DELETE`
- **Статус-коды** при ответе сервера
- **Структура сообщения** - `Заголовки`(`мета-информация`) и `Тело`(`данные запроса`)
- **Безсостояний протокол** - Каждый `запрос от клиента к серверу` считается независимым и `не связанным с предыдущими/будущими запросами`. 
  Сервер не сохраняет состояние клиента между запросами.

## _Структура HTTP запроса_

![[Pasted image 20231115192835.png]]

- **Start Line** - `Метод` / `URI к ресурсу на сервере` / `Версия HTTP`
- **Заголовки** - Бывают `обязательные` и `опциональные`
	- **Host** - Указывает на `сервер к которому идет запрос`
	- **Content-Length** - `Длинна` тела сообщения `в байтах`
	- **Content-Type** - `Тип данных` в теле запроса/ответа
- **Тело** - Содержит `полезные данные` (например данные формы) 

## _Структура HTTP ответа_

![[Pasted image 20231115200116.png]]

- **Status Line** - `Версия HTTP` / `Status-code`
- **Headers** 
- **Body** - `{...} | null`

![[Pasted image 20240303201409.png]]

## _Методы HTTP_

- **GET** - получение ресурса.
- **POST** создание нового ресурса.
- **PUT** обновление существующего ресурса.
- **PATCH** обновление части существующего ресурса.
- **DELETE** удаление ресурса.

- **HEAD** получение метаданных ресурса без тела ответа.
- **OPTIONS** получение списка поддерживаемых методов и параметров для ресурса.
- **CONNECT** установление сетевого соединения с ресурсом.
- **TRACE** получение диагностической информации о запросе и ответе на него от сервера.

## _Cookie_

**Cookie** - Небольшие `фрагменты данных`, отправляемые `при запросе/ответе в виде заголовков`. 
Позволяют `идентифицировать пользователя`, и не запрашивать аутентификацию повторно. 

- Сохранение сеанса
- Персонализация контента
- Отслеживания поведения пользователя 


![[Pasted image 20240303195135.png]]

## _Secure/HttpOnly cookie_

- **Secure** - Передача cookie `только по HTTPS протоколу`. 
  Но это не шифрует и не защищает от уязвимости куки при хранении.
- **HttpOnly Cookie** - `Запрещает доступ` к куки через `JS`(`document.cookie`), что обеспечивает защиту от `XSS`. Например для сессионных кук.

## _HTTP vs HTTPS_

1. **Безопасность:**
    - **HTTP:** Передача данных в открытом, `незашифрованном виде, как обычный текст`.
    - **HTTPS:** Шифруется через протокол `SSL`/`TLS`. Это дает `защиту от прослушивания и модификации данных`.
2. **Использование портов:**
    - **HTTP:** Использует порт 80 по умолчанию.
    - **HTTPS:** Использует порт 443 по умолчанию.
3. **Сертификаты безопасности:**
    - **HTTP:** Не требует установки SSL-сертификатов.
    - **HTTPS:** Требует `наличие корректного SSL-сертификата`, который удостоверяет подлинность веб-сайта.
4. **SEO-рейтинг:**
    - **HTTP:** Google и другие поисковые системы могут наказывать веб-сайты без шифрования в рейтинге поисковой выдачи.
    - **HTTPS:** Веб-сайты с использованием HTTPS получают преимущества в SEO-рейтинге, что может улучшить их позицию в результатах поиска.

## _HTTP/ 1 vs HTTP/ 2_

**HTTP/ 2:**
- **Мультиплексирование** - Чем больше было запросов, тем медленней работал браузер. Отправляет сразу `несколько запросов через одно соединение`.
- **Сжатие заголовков** - За счет `передачи` в виде `бинарных данных`.
- **Sever Push** - Позволяет серверу `отправлять ресурсы заранее до их запроса`. 
  Вместо того чтобы дожидаться запроса на каждый отдельный ресурс, сервер может предсказать, какие ресурсы (например, стили, скрипты, изображения) понадобятся клиенту для полной загрузки страницы.
- **Приоретизация** - Обозначает `приоритетность разных запросов`, для поддержания скорости мультиплексирования.(например: `1. scripts, 2. img`)
- **Безопасность** - `TLS шифрование - required`

## _Разница между протоколами TCP и UDP?_

Описывают `способы соединения` между `устройствами`.
То, `как будут передаваться данные`, форматы отправки запросов, `действия в случае потери данных` и так далее.

- **TCP** - Гарантирует `целостность` и `порядок` приходящий `данных, в ущерб скорости`.
- **UDP** - `Быстрая передача`, возможны `потери` и `ошибочность порядка` данных.

## _WebSocket_

**WebSocket** - Двунаправленный протокол, позволяющий `поддерживать постоянное соединение` и `обмениваться данными в режиме реального времени`.

Он `начинает` свою `работу с обычного HTTP-запроса`, который `затем обновляется до WebSocket-соединения`, после чего данные могут передаваться в обоих направлениях без необходимости постоянных новых HTTP-запросов.

## _Long-Polling / Server-Sent Events / Websockets_

**Long-Pooling, Server-Sent Events и Websockets** - все это `технологии` для поддержания `real-time обновлений`, но с разными подходами.

- **Long-Polling** - `Клиент делает запрос`, `сервер задерживает ответ до наличия обновлений`.  Однонаправленный обмен. Могут быть задержки.
- **Server-Sent Events(SSE)** - Однонаправленное соединение, где `сервер отправляет уведомления`. Ограничен однонаправленным потоком данных.
- **WebSockets:** Полнодуплексное соединение, `обеспечивает эффективное двустороннее взаимодействие` в режиме реального времени. Эффективен, `но требует поддержки на сервере и клиенте`.

## _Как работает JSONP?_

**JSONP** - Это `обход политики безопасности при запросе к иным доменам`, не связанных с клиентским сайтом. 

Использование происходит через установку в `<head>` тега `<script>`, с атрибутом `src="адрес_запроса"`
- Скрипт `будет загружен несмотря на домен` на котором мы находимся. 
- Вернет `не JSON`, а `сallback({ "user": "Rrooom", "message": "test" });`

- Небезопасно, так как открывает возможность для атаки XSS.
- Ограничено использованием только для GET-запросов.

## _IndexedDB_

**IndexedDB** - Оффлайн база данных на стороне клиента, способна занимать до 50% пространства на жестком диске. Как правило используется в расширениях для браузера.

## _Service Worker и Web Worker_

**Service Workers** и **Web Workers** - Это два разных концепта в веб-разработке.

- Оба `предоставляют возможность` выполнять код `в фоновом режиме`, `не блокируя основной поток` выполнения. Не имею доступ к DOM.

1. **Цель использования:** 
   - **Service Workers:** Предназначены `для работы с сетевыми запросами, кэширования и обработки событий` в фоновом режиме для веб-приложений.
   - **Web Workers:** Используются `для выполнения вычислительно интенсивных задач` в фоновом режиме.
2. **Область применения:** 
   - **Service Workers:** В основном `связаны с веб-приложениями` и их `функциональностью в оффлайн. 
   - **Web Workers:** Используются для `улучшения производительности` в вычислительных задачах.

## _Service Worker_

**Service Worker** - Это `скрипт` JavaScript, который` регистрируется в браузере` и остается в нем `даже при отсутствии интернета`.

- Работает `в отдельном потоке` от основного, `в фоновом режиме`. Поэтому является параллельным и `неблокирующим код`. 
- Позволяет `кешировать ресурсы` и `работать оффлайн`.
- Является `посредником` между клиентом и сервером, способен `перехватывать запросы`, а так же управлять ими `даже когда веб-приложение закрыто`.

- Не имеет прямого доступа к `DOM`
- Работает `только по HTTPS` из соображений безопасности.


![[Pasted image 20240306165846.png]]

## _Web Workers_

**Web Worker** - Скрипт используемый `для выполнения сложно-нагруженных вычислений`, `без блокировки` основного `потока` и `интерфейса`. Выполняется в фоне.


![[Pasted image 20240306171811.png]]

## _Web Worklet_

**Web Worklet** - Позволяет `встраивать` пользовательский код `в критические этапы рендеринга`(`style, layout, paint, composite`), выполняя их асинхронно в фоне. 

Это позволяет `вынести ресурсоемкие операции` при рендеринге `в отдельный поток`,
тем самым `увеличив скорость отрисовки страницы`.

Пример использования `Web Worklet` может быть связан `с анимациями или эффектами`, которые `требуют сложных вычислений`. 

![[Pasted image 20240306185642.png]]

## _SSL/TSL_

**SSL/TSL** - Протоколы транспортного уровня, занимающиеся `защитой пользовательских данных при их передаче`.

При подключении `SSL/TLS`, клиент устанавливает защищенное шифрованием соединение через `HTTPS`. 

**TLS** обеспечивает 3 фактора при обмене данными:
- **Конфиденциальность** - Можно перехватить, но `не узнать содержимое`.
- **Целостность** - `Защита от модификации данных` во время транспортировки.
- **Аутентификация** - Гарантирует `подлинность сервера` с которым происходит общение. Подтверждение происходит за счет сертификата.

В `TLS` применяются `симметричные` и `асимметричные` механизмы шифрования:
- **Симметричное шифрование** - Для шифрования и дешифрирования используется `один и тот же ключ`.
- **Асимметричное шифрование** - Используются `2 ключа`.
  - `Публичный` ключ - шифрует данные
  - `Приватный` - дешифрует данные

![[Pasted image 20240306193616.png]]

## _Установка сеанса между клиентом и сервером_

- Клиент отправляет запрос на сервер
- `Сервер` генерирует и `устанавливает ID сеанса в куки`
- При каждом следующем запросе используется `session-id`
- Сервер возвращает нужные данные основываясь на `session-id`, тем самым  поддерживая сессию


![[Pasted image 20240306200935.png]]

## _API_

**API (Application Programming Interface)** - Программный `интерфейс` который имеет в себе `различные endpoint's для взаимодействия с данными` на сервере. 

Как правило взаимодействие происходит на основе CRUD операций.

## _CDN_

**CDN (Content Delivery Network)** - Распределенная `сеть серверов`, которая ориентирована на `улучшение скорости доставки контента`, за счет загрузки данных с ближайшего сервера. 

## _Разница между host и domain?_

**Домен** используется для поиска `IP` **Хоста** в системе доменных имен.

- **Host** - Сервер, который`содержит сайт`.
- **Domain** - Человеко-читаемый адрес сайта.

Когда в браузер `вводится доменное имя`, то под капотом, `через DNS`, идет `запрос к IP адресу хоста` ассоцированному с этим именем.

## _URI и URL_

- **URI (Identifcator)** - `Имя и Адрес ресурса` в сети (`URL+ URN`)
- **URL (Location)** - `Адрес ресурса` и `Протокол обращения` к нему.
- **URN (Name)** - `Имя ресурса`, но не говорит как к нему подключиться.

- URI - `https://wiki.merionet.ru/images/vse-chto-vam-nuzhno-znat-pro-devops/1.png`
- URL - `https://wiki.merionet.ru`
- URN - `images/vse-chto-vam-nuzhno-znat-pro-devops/1.png`

## _Идентификация/аутентификация/авторизация_

- **Идентификация** - процедура установления личности.
- **Аутентификация** -  подтверждение личности, например `сравнение введенного логина и пароля с существующими в базе данных`.
- **Авторизация** - `определение прав и доступов`.

![[Pasted image 20240307161038.png]]

## _Виды аутентификации_

- **Form-based** - предоставление данных через форму на странице
- **Token-based** - предоставление специального токена после успешной аутентификации
- **OAuth** - с помощью социальных сетей
- **Two-factor** - двухфакторная
- **Biometric** - на основе отпечатков пальцев или сканирование лица
- **Certificate-based** - пользователь предоставляет сертификат который ему выдается
- **OpenID** - открытый стандарт который позволяет использовать одну учётную запись для доступа к нескольким веб приложениям
- **One-time password** - одноразовый пароль действующий только в пределах текущей сессии или на короткий период времени

## _CORS (Cross-Origin Resource Sharing)_

**CORS (Cross-Origin Resource Sharing)** - Позволяет `серверу указать`, какие конкретные `домены могут запрашивать его ресурсы`. 
Это делается с помощью HTTP-заголовков, таких как `Access-Control-Allow-Origin`.  

Проверка сходства источников:
- Тип протокола (`http/https`)
- Хост (`example.com`)
- Порт (`80/433`)

- **CORS** позволяет сайту A дать разрешение сайту B на чтение (потенциально конфиденциальных) данных с сайта A (используя браузер и учетные данные посетителя).
- **CSP** позволяет сайту на котором установлен этот заголовок предотвратить загрузку (потенциально вредоносного) содержимого из неожиданных источников (например, в качестве защиты от XSS).

## _Content Security Policy (CSP)_

**CSP** - Позволяет `контролировать откуда могут быть загружены ресурсы` на их сайт.
Лучший способ предотвращения выполнения вредоносного кода внедренного через XSS.

```
<head> 
	<meta 
		http-equiv="Content-Security-Policy" 
		content="default-src 'self'; 
		script-src 'self' https://trusted-scripts.com; 
		style-src 'self' https://trusted-styles.com";
	>
</head>
```

![[Pasted image 20240307170552.png]]

## _XSS-атака_

**Межсайтовый скриптинг** - Внедрение `вредоносного кода на сервер` сайта `через input-поле` страницы. Вредоносный код будет выполняться при загрузке странице на стороне клиента, `производя отправку данных клиента` на сторону злоумышленника. 

## _Безопасный vs Идемпотентный метод_

- **Безопасный метод HTTP** - `Не модифицирует данные`, и `не имеет побочных` эффектов. 
  (`GET, HEAD и OPTIONS`)
- **Идемпотентный метод** - При `повторном вызове с одинаковыми параметрами`, метод `не повлечет модификации` данных на сервере.
  Методы `GET, PUT, DELETE` - идемпотентены. `POST` - не идемпотентен, тк создает ресурс при каждом запросе.

- **HEAD** - Аналогичен `GET`, `но возвращает только заголовки` 
- **OPTIONS** - Получение `информации о возможностях сервера` и доступных методов запроса.

## _HTTP коды_

- **Информационные** 100 - 199
- **Успешные** 200 - 299
- **Перенаправления** 300 - 399
- **Клиентские ошибки** 400 - 499
- **Серверные ошибки** 500 - 599

## _BOM_

**BOM (Browser Object Model)** - Это API браузера, предоставляет доступ для взаимодействия с браузером.

- document
- navigator
- location
- history
- screen

Это позволяет взаимодействовать с окном браузера, с историей, устанавливать таймеры.
	
## _Что происходит после запроса сайта_

- **Получение IP-адрес сервера**
	- Кеш `локальный`
	- Кеш `провайдера`
	- Поиск по цепочке в `Системе доменных имен`.
- **Установка соединения с сервером** через `TCP` протокол (через `HTTP/HTTPS`)
- **Запрос на получение** нужной `страницы`
- **Сервер формирует и отправляет** `HTTP-ответ` (`status-code`, `заголовки`, `body`)
- **Браузер обрабатывает полученные ресурсы**(`HTML/CSS/JS`) и `отрисовывает страницу` на клиенте.

## _Architecture_

## _Отличие ООП от Процедурного программирования_

![[Pasted image 20240309195746.png]]
Программа написанная в процедурном стиле:
- `Ожидает на вход` какие-то `данные`
- `Выполняет` ряд каких-то `процедур`
- `Возвращает` какой-то `результат`

Изначально все программы писались в процедурном стиле. Но по мере разрастания кода - подход стал неудобен

## _Объектно-ориентированный подход_

![[ООП]]

## _SOLID_ 

![[SOLID]]

## _Функциональная парадигма_

![[FP]]

## _Архитектурные принципы (помимо SOLID)_

![[KISS & YAGNI]]

## _Плюсы и минусы FP и ООП_



## _Архитектура внутри проекта_

**Архитектура** - Главная задача `сделать части системы независимыми друг от друга`, чтобы в любой момент их можно было заменить на иной элемент

- **Интерфейс** - Графический `интерфейс с которым взаимодействует пользователь`
- **Бизнес логика** - Функционал который `приносит конкретную пользу бизнесу`
  (`регистрация пользователя, добавление в корзину, оплата`)
  
## _MVC_

**Model  View Controller** 
- **Viev** - UI интерфейс 
- **Controller** - Связующее `звено-абстракция между интерфейсом и логикой`. Позволяет `избежать сильной связанности между интерфейсом и логикой`.
- **Model** - Бизнес-логика приложения.

![[Pasted image 20240313022312.png]]

![[Pasted image 20240313021857.png]]

![[Pasted image 20240313021809.png]]

- **MVP** - минимальный набор функций для тестирования проекта на рынке и сбора обратной связи пользователей
  
## _Модульная архитектура_

- `Вышестоящие` слои могут `использовать` только `нижележащие` слои
- `Нижележащие` слои `не могут` использовать `вышестоящие`
- `Никто не может` использовать `элементы своего уровня`

![[Pasted image 20240313024420.png]]

- **UI** - Никакой бизнес логики, только элементы интерфейса

![[Pasted image 20240313025029.png]]

- **Components** (`например карточка товара, комментарий`)
  
![[Pasted image 20240313025150.png]]

- **Modules** - Внутри находится `вcе необходимое для работы этого модуля`

![[Pasted image 20240313025445.png]]

- **Pages** - Максимально тонкий. Собирает в себе несколько `Modules`

## _Atomic Design_

Примерно аналогична модульной архитектуре

![[Pasted image 20240313025738.png]]
![[Pasted image 20240313025910.png]]

## _Feature Sluce Design (FSD)_

![[FSD]]

## _Микросервисы_

Большое монолитное приложение разбивается на смысловые отдельные сервисы. 

![[Pasted image 20240313033918.png]]

