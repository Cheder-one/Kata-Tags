## _Web Technologies_

## _Прогрессивный рендеринг_

**Прогрессивный рендеринг** - для ускорения загрузки и отрисовки страницы.

Его цель - предоставить `минимальный и необходимый контент как можно быстрее`. 
А `затем дополнять` его `по мере продвижения`.

- **Lazy Loading** изображений
```
<img
	src="placeholder.jpg" /=/ Легкое изображение-заглушка
	data-src="image.jpg" /=/ Фактический источник изображения
	alt="Lazy-loaded image"
	loading="lazy"
>
```

- **Server-Side Rendering** - Сервер рендерит(выстраивает) HTML-страницу у себя и отправляет клиенту уже готовую. 
  Это освобождает клиента от затрат ресурсов на отрисовку.

## _Progressive Web Application (PWA)_

**PWA** - позволяет использовать `веб-сайт как нативное приложение` на разных платформах. 
- `Оффлайн` и `быстрая загрузка`, благодаря `кешированию` `Service worker's`
- Не нужно скачивать обновления, есть полная интеграция с устройством. 

**Service worker** - Это `фоновый скрипт`, не блокирующий основной поток выполнения кода. Способен `перехватывать запросы к серверу`, возвращая кеш при необходимости.

## _Кроссбраузерность_

**Кроссбраузерность** - Способность сайта `корректно отображаться` `в разных браузерах` и `в разных версиях`, а так же `на разных устройствах`.

- Верная `семантика тегов`

- Использование `reset / normalize`
- `Вендорные префиксы` браузеров и `Адаптивная верстка`

- Применение `Progressive Enhancement / Graceful Degradation`
- `Полифилы` для `поддержания функциональности`(`Babel`)

## _Модель OSI_

**Модель OSI** - состоит из `7 уровней абстракций` и `описывает как работает интернет`.

Каждый `слой имеет свой протокол` с правилами и `не знает о других слоях`, он просто делает свою работу

- Физический;
- Канальный;
- Сетевой;
- Транспортный;
- Сеансовый;
- Представления;
- Прикладной.

![[Pasted image 20240301164125.png]]

- Самый `нижний слой` отвечает за `физическую передачу` данных(`по проводам/радиоволнам`)
- Самый `верхний слой` за то `как приложение взаимодействует с сетью`. 
  Этот слой описывают протоколы:
	- `HTTP` (Hypertext Transfer Protocol) — самый популярный протокол для передачи данных по интернету.
	- `FTP` (File Transfer Protocol) — ещё один известный протокол, заточенный под передачу файлов. 
	- и тд

## _Поток документа_

**Поток документа** - `описывает поведение` того, `как элементы должны располагаться` на странице. 

- `Стандартный поток` документа формируют `блочные` и `строчные` типы элементов
- Изменить стандартный поток: `flex/grid/float`, `position`

## _Адаптивный vs Отзывчивый дизайн_

- **Адаптивный дизайн** - Имеет `несколько макетов для каждого устройства`. Используются `@media`.
- **Отзывчивый дизайн** - Имеет `1 макет для всех устройств`. 
  Использует `Flexbox` и `относительные единицы`(`rem, %`).

## _Progressive Enhancement vs Graceful Degradation_

Оба этих подхода `используются для поддержания кроссбраузерности и кроссплатформенности` сайта.

- **Progressive Enhancement** - От простого к сложному
- **Graceful Degradation** - Функционал деградирует от сложного к простому.

Предпочтительней использовать `Progressive Enhancement` т.к. он обеспечивает `более предсказуемый результат`.

## _Веб-компоненты_

**Веб-компоненты** - Позволяют создавать свои `переиспользуемые компоненты в виде HTML-тегов`. Они работают `напрямую браузером` и `без библиотек`.

## _RESTfull API_

- **REST** - `Aрхитектурный стиль`, 
- **RESTfull** - `Cервис` который `следует данной архитектуре`.
- **API** - `Интерфейс для взаимодействия с ресурсами` на сервере `через` указанные в документации `endpoint's`.

## _Концепция REST_

### _1. Клиент-серверная модель архитектуры_   

- **API** - `Сервер`
  Отвечает за `хранение данных` и `выполнение бизнес-логики`.
- **Клиент** - `Любое устройство`(`PC/mobile/server`)
  Отвечает за `визуализацию данных` и `взаимодействие с пользователем`.
  
Клиент-серверное `общение`, осуществляется `в виде запросов и ответов`.

### _2. Многоуровневость системы_

Клиент может `взаимодействовать с разными слоями сервера и не подозревать об этом`.

Сервер может иметь множество слоев с балансированием по другим серверам. 
Но `с точки зрения Клиента, система должна быть цельна`.

### _3. Отсутствие состояния_

При каждом запросе, `сервер и клиент общаются как в первый раз`. 

Для того чтобы `сервер идентифицировал` клиента и `понял что требуется сделать`,` клиент должен отправить вместе с запросом всю необходимую информацию`.

### _4. Единообразие интерфейса_

- Взаимодействие с ресурсами через `CRUD-операции`.
- Для каждого `ресурса существует свой путь`(`URL`) `для взаимодействия` с ним.

### _5. Кеширование_

Реализация кеширования запросов к серверу.

- Кеширование `GET` и `POST` запросов `через` проставление времени в `заголовки` `Cache-Control`.
- Не стоит кешировать `PUT` и `DELETE` запросы, тк они изменяют состояние сервера.

## _Критические этапы рендеринга_

**Critical Rendering Path** - Это `последовательность этапов`, которые выполняет браузер для того `чтобы преобразовать HTML, CSS и JS в конечное изображение` на экране.

![[Pasted image 20240301214536.png]]

- **Реализация** `DOM`(`Document Object Model`) на основе парсинга `HTML`.
- **Реализация** `CSSOM` на основе подключенных к документу стилей
- **Реализация** `JS` с возможной модификацией `DOM`.

- **Поиск** `a11y` атрибутов в `HTML`. Выстраивается `Accessibility Tree` для чтения `скринридерами`.

- **Объединение** `DOM + CSSOM` в `Render Tree`. В нем находится только видимое содержимое.
- **Расположение** элементов и расчет размеров (`Layout/Reflow`)
- **Покраска** элементов согласно заданным стилям (`Paint/Repaint`)

- **Позиционирование слоев**  элементов их `z-index` (`Compositing`)

## _Когда происходит Reflow и Repaint?_

- **Reflow(Пересчет)** - Происходит `при изменении геометрии элемента`(`изменение размеров` или `положения`). 
  Reflow `влечет за собой перерасчет` геометрии `всех остальных элементов`.
- **Repaint(Перерисовка)** - Касается только `визуальных изменений`(например, `background-color`). Не требует пересчета геометрии, менее затратен.

## _Flash Of Unstyled Content (FOUC)_

**Flash of Unsyled Content** - Вспышка нестилизованного контента. 
Это `появление неоформленного контента при загрузке`

- Размещать критический `CSS` в `<head>`
- Добавлять `Loader` или `Skeleton` до полной загрузки контента.

## _History API в браузере_

**History API** - позволяет `манипулировать историей браузера` с иcпользованием JS, через объект `window.history`.

## _Web Storage_

**Web Storage** - позволяет хранить данные пользователя в браузере.
- `cookie`
- `localStorage`
- `sessionStorage`

## _cookie/sessionStorage/localStorage_

|                 | cookie                     | sessionStorage      | localStorage  |
| --------------- | -------------------------- | ------------------- | ------------- |
| Инициатор       | Клиент/Сервер (Set-Cookie) | Клиент              | Клиент        |
| Срок хранения   | Установка вручную          | До закрытия вкладки | Не ограничено |
| Связь с доменом | Да                         | Нет                 | Нет           |
| Емкость         | 4 Kb                       | 5 Mb                | 5 Mb          |
| Доступность     | Любое окно                 | Только вкладка      | Любое окно    |

## _Как уменьшить скорость загрузки страницы?_

- **Минификация** файлов(`удаление лишних пробелов и символов`) 
- **Объединение** файлов в один - это `уменьшит кол-во запросов`.
- **Сжатие** изображений.
- **Кеширование** ресурсов `через HTTP-заголовки`.
- **Использование CDN** для `использования данных с ближайшего сервера`.

## _Core Web Vitals_

**Core Web Vitals** - `метрики для оценки user-experience` при взаимодействии с сайтом.

- `Скорость загрузки наибольшего контента` на странице.
- `Задержку при взаимодействии`. 
- `Стабильность макета при загрузке` страницы.

## _Разница между preload, prefetch, preconnect и prerender?_

Данные свойства `используются` `в атрибуте` `rel` `для оптимизации загрузки` ресурсов.

1. **preload** - Загрузить `с высоким приоритетом и кешировать` ресурс. 
   Применение: Если ресурс может понадобиться через несколько секунд после загрузки страницы.
2. **prefetch** - Загрузить `в фоновом режиме, с низким приоритетом и кешировать`.
   Применение: Если ресурс понадобится на след. странице или в подменю.
3. **preconnect** - Заранее подключиться к домену
4. **prerender** - Загрузить и открыть `страницу в невидимой вкладке`, для моментального открытия.
   Применение: Если мы уверены что пользователь посетит эту страницу и хотим ускорить ее отображение.

![[Pasted image 20240302173226.png]]

## _Для чего нужен паттерн PRPL?_

**PRPL** - Описывает `4 этапа оптимизации при загрузке приложения`.

- **Push**(**Preload**) - Упор на `загрузку минимального контента для отображения`
  (`HTML, CSS, критический JS`)
- **Render** - После загрузки основного `контента`, приложение должно быть способно `быстро отобразить его на экране`. 
- **Pre-cache** - `Предварительное кеширование ресурсов`, которые `могут быть запрошены при дальнейших действия` пользователя.
- **Lazy-load** - Загрузка `некритических` ресурсов `асинхронно` или `по требованию`.

## _Разница между SSR и SSG и CSR?_

**SSR (Server-Side Rendering) и SSG (Static Site Generation)** - это `два подхода к генерации веб-страниц`.

**SSR (Server-Side Rendering):**
- **Как это работает:**
    - Сервер `генерирует HTML на сервере при каждом запросе` к странице.
    - Полная разметка страницы отправляется клиенту, включая данные.
- **Преимущества:**
    - Лучшая `SEO-оптимизация,` поскольку поисковые системы получают полностью сформированные страницы.
    - Лучшая `производительность для первой загрузки`, особенно на медленных устройствах или соединениях.
- **Недостатки:**
    - Больше `нагрузка на сервер`, так как каждый запрос требует повторной генерации страницы.
    - Б*о*льшая `задержка в интерактивности` на стороне клиента.

**SSG (Static Site Generation):**
- **Как это работает:**
    - Страницы `генерируются во время сборки` (`build time`) и сохраняются как статические файлы.
    - Клиентам отдается готовый HTML-контент.
- **Преимущества:**
    - Отличная `производительность`, так как `не требуется повторной генерации для каждого запроса`.
    - Возможность кэширования статических файлов на CDN.
- **Недостатки:**
    - `Обновление` данных может `потребовать пересборки сайта`.

**CSR (Client-Side Rendering):**
- **Как это работает:**
    - Исходный `HTML-код отправляется на клиент`, а затем браузер выполняет `JavaScript`, который `генерирует и вставляет контент`.
    - AJAX-запросы используются для получения данных после загрузки страницы.
- **Преимущества:**
    - `Быстрая интерактивность на стороне клиента` после первоначальной загрузки.
    - Удобство работы с динамическими данными.
- **Недостатки:**
    - `Проблемы с SEO`, так как поисковые системы могут иметь ограниченный доступ к динамическому контенту.
    - `Медленная первая загрузка`, особенно на медленных соединениях.

## _Babel_

**Babel** - инструмент для трансляции кода с одной версии на другую, для поддержания кроссбраузерности. Это позволяет использовать новейшие фичи языка.

## _feature detection/feature inference и user-agent_

`Feature detection`, `feature inference` и анализ строки `user-agent` - предназначены для `определения отдельных возможностей` браузера и `его характеристик`. 

- **Feature detection** - `Проверяет` наличие `отдельных функций и возможностей` в браузере. (наиболее надежный и современный метод)
```
if ('geolocation' in navigator) {
    /=/ Use navigator.geolocation
} else {
    /=/ Полифил заменяющий функционал
}
```
- **Feature interface** - `Предположение` о возможностях браузера,` на основе других возможностей`.
```
if (document.addEventListener) {
    /=/ Используем addEventListener, предполагая, что браузер современный
} else {
    /=/ Браузер устарел, используем attachEvent
}
```
- **User-Agent** - Заголовок `User-Agent` отправляется с каждым запросом на сервер. 
  Предоставляет информацию `о браузере`, `операционной системе` и тд
```
var userAgent = navigator.userAgent;

// "Mozilla/5.0 (X11; Linux x86_64; rv:123.0) Gecko/20100101 Firefox/123.0"
```

## _Что такое блокирующие и неблокирующие ресурсы?_

- **Блокирующие ресурсы** - `Необходимы при отображении страницы`, `блокируют парсер`. Выполнение `других частей кода будет приостановлено`, пока ресурс не загрузится.
	- Файл `CSS` в `<head>`
	- JS в теге `<script>`, без атрибута `async` или `defer`
- **Неблокирующие ресурсы** - Могут быть `загружены асинхронно`, `не блокируя парсер и процессы`. 
	- Загрузка изображения через тег `<img>`
	- Загрузка видео через тег `<video>`
	- Асинхронные `AJAX` запросы

## _Что такое GraphQL?_

**GraphQL** - `язык запросов` к API. Позволяет `запрашивать только те данные - которые нужны`.

- Получение `только запрашиваемых данных`
- Существует `единый endpoint` для всех запросов
- Лучше `производительность` API, за счет `уменьшения кол-ва запросов` и `объема передаваемых данных`.

```
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const client = new ApolloClient({
  uri: 'https://example.com/graphql', /=/ Замените на ваш реальный GraphQL endpoint
  cache: new InMemoryCache(),
});

/=/ Пример запроса
client
  .query({
    query: gql`
      query {
        user(id: 1) {
          id
          username
          email
        }
      }
    `,
  })
  .then(result => console.log(result));
```

Недостатки GraphQL:
- Сложность: GraphQL может быть сложным для понимания и использования, особенно для новичков.
- Кэширование: из-за гибкости GraphQL сложнее кэшировать запросы, что может привести к проблемам с производительностью.
- Уязвимость к DoS-атакам: из-за возможности запрашивать большое количество данных, GraphQL может быть уязвим к DoS-атакам.

## _Web API_

## _Что такое HTTP?_

**HTTP (HyperText Transfer Protocol)**  - Протокол для `передачи данных` в сети. 
Основное назначение - `обеспечение коммуникации между клиентом и сервером`. 

**HTTP** определяет то, `как клиент и сервер должны общаться`:
- **Методы запросов** `GET, POST, PUT, PATCH, DELETE`
- **Статус-коды** при ответе сервера
- **Структура сообщения** - `Заголовки`(`мета-информация`) и `Тело`(`данные запроса`)
- **Безсостояний протокол** - Каждый `запрос от клиента к серверу` считается независимым и `не связанным с предыдущими/будущими запросами`. 
  Сервер не сохраняет состояние клиента между запросами.

## _Структура HTTP запроса_

![[Pasted image 20231115192835.png]]

- **Start Line** - `Метод` / `URI к ресурсу на сервере` / `Версия HTTP`
- **Заголовки** - Бывают `обязательные` и `опциональные`
	- **Host** - Указывает на `сервер к которому идет запрос`
	- **Content-Length** - `Длинна` тела сообщения `в байтах`
	- **Content-Type** - `Тип данных` в теле запроса/ответа
- **Тело** - Содержит `полезные данные` (например данные формы) 

## _Структура HTTP ответа_

![[Pasted image 20231115200116.png]]

- **Status Line** - `Версия HTTP` / `Status-code`
- **Headers** 
- **Body** - `{...} | null`

![[Pasted image 20240303201409.png]]

## _Методы HTTP_

- **GET** - получение ресурса.
- **POST** создание нового ресурса.
- **PUT** обновление существующего ресурса.
- **PATCH** обновление части существующего ресурса.
- **DELETE** удаление ресурса.

- **HEAD** получение метаданных ресурса без тела ответа.
- **OPTIONS** получение списка поддерживаемых методов и параметров для ресурса.
- **CONNECT** установление сетевого соединения с ресурсом.
- **TRACE** получение диагностической информации о запросе и ответе на него от сервера.

## _Cookie_

**Cookie** - Небольшие `фрагменты данных`, отправляемые `при запросе/ответе в виде заголовков`. 
Позволяют `идентифицировать пользователя`, и не запрашивать аутентификацию повторно. 

- Сохранение сеанса
- Персонализация контента
- Отслеживания поведения пользователя 


![[Pasted image 20240303195135.png]]

## _HTTP vs HTTPS_

1. **Безопасность:**
    - **HTTP:** Передача данных в открытом, `незашифрованном виде, как обычный текст`.
    - **HTTPS:** Шифруется через протокол `SSL`/`TLS`. Это дает `защиту от прослушивания и модификации данных`.
2. **Использование портов:**
    - **HTTP:** Использует порт 80 по умолчанию.
    - **HTTPS:** Использует порт 443 по умолчанию.
3. **Сертификаты безопасности:**
    - **HTTP:** Не требует установки SSL-сертификатов.
    - **HTTPS:** Требует `наличие корректного SSL-сертификата`, который удостоверяет подлинность веб-сайта.
4. **SEO-рейтинг:**
    - **HTTP:** Google и другие поисковые системы могут наказывать веб-сайты без шифрования в рейтинге поисковой выдачи.
    - **HTTPS:** Веб-сайты с использованием HTTPS получают преимущества в SEO-рейтинге, что может улучшить их позицию в результатах поиска.

## _HTTP/ 1 vs HTTP/ 2_


## _WebSocket_

**WebSocket и HTTP** - это разные протоколы. WebSocket является протоколом, обеспечивающим полнодуплексное(`bidirectional`) взаимодействие между клиентом и сервером. Он начинает свою работу с обычного HTTP-запроса, который затем обновляется до WebSocket-соединения, после чего данные могут передаваться в обоих направлениях без необходимости постоянных новых HTTP-запросов.