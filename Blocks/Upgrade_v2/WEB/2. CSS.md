## _Специфичность CSS-селекторов_

**Специфичность**  - это некие `веса`, по которым `браузер определяет какие стили применить к элементу`, если есть несколько конфликтующих правил.

Специфичность определяется как `число` `из 4 разрядов`.

1. **Инлайновые стили: 1000**
```
<p style="color: red;">Этот текст будет красным.</p>
```
2. **ID: 0100** 
```
#header {
    font-size: 24px;
}
```
3. **Классы, псевдоклассы и атрибуты: 0010**
```
.highlight {
    background-color: yellow;
}
button:hover {
    color: white;
}
input[type="text"] {
    border: 1px solid #ccc;
}
```
4. **Теги и псевдоэлементы: 0001**
```
p::before {
    content: "Текст перед параграфом";
}
```
- **Порядок расположения в коде** - конечный решающий фактор.

## _reset vs normalize_

- **reset** - Сбрасывает все стили к исходному значению 
- **normalize** - Приводит стили к единому виду для всех браузеров 

Я бы выбрал `normalize`, тк он опционально `изменяет нужные стили`, а не затирает все и `сохраняет кроссбраузерность`.

## _float элементы_

Основное предназначение `float` - обтекание элемента текстом. 
Когда элементу устанавливается `float: left;` или `float: right;`, то 
- элемент вынимается из потока и остается видимым только для `inline-block` элементов.
- прижимается к выбранному краю родительского контейнера.

![[Pasted image 20240227123207.png]]

### _Псевдораспорки_

Для избежания непредсказуемых сдвигов контента, используем `clearfix`.

-> Устанавливаем распорки(`псевдо-content`) элементу, через `::after`
```
.container::atfter {
	content: "";
	display: table:
	clear: both; /=/ Отказ от обтекания другими элементами со всех сторон.
}
```

## _z-index и stacking context_

- **z-index** - Определяет `приоритет расположения одного элемента над другим` в рамках своего контекста наложения. Работает только при заданном `position`
- **position** - Устанавливает тип позиционирования
	- `static` (по умолчанию) - располагается в потоке документа.
	- `relative` - позиционируется `относительно` своего `обычного положения`.
	- `absolute` - позиционируется `относительно` ближайшего `позиционированного предка`.
	- `fixed` - позиционируется `относительно` видимой области `окна` браузера.
	- `sticky` - позиционируется в зависимости `от прокрутки`.
- **stacking context** - Описывает, `как элементы взаимодействуют` друг с другом `при изменении` их приоритета `по оси z`.
  Контекст наложения может формировать:
  - Корневой элемент `<html>
  - Любой `позиционированный элемент`, если `position !== static && auto`
  - Элемент-бэкграунд имеющий `opacity <= 1`
  - Дочерний элемент `flex/grid` контейнера, если `z-index !== auto`.

## _Решение стилевых проблем разных браузеров_

- Использование `normalize` или `reset`
- Использование `autoprefixer`, оно устанавливает вендорные префиксы 
	- `Вендорные префиксы` это приставки перед css-свойствами, которые позволяют внедрять `экспериментальные стили`, а так же используются для `улучшения кроссбраузерности`.  

## _Отображение страниц в старых браузерах_

- Использование `autoprefixer` для повышения кроссбраузерности
- Реализация `прогрессивного улучшения` - Разработка базового функционала, а после добавление новых технологий 
- Реализация `graceful degradation` - Разработка на современном стеки, но с реализацией `fallback'ов` для старых браузеров.

## _Стилизация SVG_

При стилизации `svg` можно использовать как `inline стили`, так и подключать `css-файлы`. Но некоторые стилевые свойства отличаются от css(`fill - background`, `stroke - border`)

```
<svg width="100" height="100">
  <circle 
	  cx="50" cy="50" r="40" 
	  style="fill: blue; stroke: white; stroke-width: 3;" 
	/>
</svg>
```

```
<?xml-stylesheet type="text/css" href="style.css"?>   
```

## _Свойства @media_

Медиа запросы могут адаптировать разные типы устройств: мониторы/телевизоры, принтеры, речевые браузеры и тд.

- **all** - Все устройства
- **screen** - Предназначен в первую очередь для цветных компьютерных экранов.
- **print** - Принтеры
- **speech** - Синтезаторы речи

## _Преимущества/недостатки препроцессоров_

- Вложенность/читаемость
- Переменные
- Миксины

- Можно перегнуть с использованием функционала и начать писать `over-engineering`

## _Блочная модель_

**Блочная модель** - отвечает за то сколько места занимает элемент, учитывать ли в `width/height` элемента, размеры свойств `padding и border`. 

```
* {
	box-sizing: border-box / content-box
}
```

## _Как браузер определяет, на какие элементы накладывать CSS стили?_

- `Парсинг HTML` и `выстраивание` на его основе `DOM`(`Document Object Model`) 
- `Парсинг CSS-таблиц`, подключенных к HTML документу. И выстраивание `CSSOM`(`CSS Object Model`)
- `Формирование дерева рендеринга` из `DOM + CSSOM`. Там `происходит сопоставление элементов` HTML с селекторами CSS и `расчет` приоритетов стилей `по их специфичности`.

## _Псевдоселекторы_

**Псевдоселекторы** - позволяют `стилизовать элемент` в зависимости от его `динамического состояния`.

```
:hover {...}
:active {...}
:first-child {...}
:nth-child(1) {...}

input:not([type="submit"]) { 
	border: 1px solid #ddd; 
}
```

## _Псевдоэлементы_

**Псевдоэлементы** - используются для `создания дополнительных виртуальных элементов` или `стилизации отдельных частей` элемента.

```
::first-line {...}
::first-letter {...}
::before {...}
::after {...}
```

## _Какими CSS-фреймворками вы пользовались?_

Использовал `Ant, Bootsrap, Tailwind, Emotion, Material UI` 
Из улучшений, `я бы добавил реализацию` большего `удобства и контроля` над кастомизацией `стилей`, например в Antd.

## _Разница между отзывчивым (responsive) сайтом и сайтом, сделанным по принципу mobile-first?_

-  **Mobile-first** - Версия сайта первоначально разрабатывается для мобильных устройств, что подразумевает его `адаптивность к ограниченным ресурсам и особенностям малого экрана`. Далее происходит улучшение до больших экранов.
- **Отзывчивый дизайн** - Начинается с верстки десктопной версии сайта. Затем она адаптируется для меньших экранов.

## _Ретиновая графика_

**Ретиновая графика** - используется `для изображений с большим разрешением`, `для устройств с высокой плотностью пикселей` 

- В таких случаях использую `SVG`
- И атрибут `srcset` для `<img>` - так браузер сам выберет необходимое изображение для устройства.
```
<img src="normal-image.jpg"
     srcset="normal-image.jpg 1x,
             retina-image.jpg 2x"
     alt="Описание изображения">
```

## _Когда использовать `translate()`, а когда `position:absolute`?_

- Для анимаций лучше использовать css-анимации, тот же `translate()`.
  `Анимации` имеют `хорошую оптимизацию в браузере` и большую `частоту кадров`, за счет быстрого рендеринга. 
- Для `точного расположения` элемента относительно чего-то, используется `позиционирование`. 
  Так же, стоит учесть, что движение через `позиционирование` -` использует пиксельную сетку`. В то время как `translate()` же использует `субпиксельную интерполяцию`, это `позволяет перемещаться анимации на доли внутри пикселя`.