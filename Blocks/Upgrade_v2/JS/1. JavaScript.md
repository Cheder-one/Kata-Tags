## _Типы данных_

8 типов:
- `string`
- `number` - для любых чисел, но с ограниченным диапазоном 
- `bigInt` - числа произвольной длины 
- `boolean`
- `null`
- `undefined`
- `sumbol`
- `object`

`NaN` и `Infinity` - это значения типа `number`

- **Примитивные данные** - Хранятся в `stack` или `внутри контекста` выполнения `функции`. Имеет `статический размер`.
- **Ссылочный тип данных** - Хранится в `heap`(`куче`). Это: (`Function`, `Array`, `Object`)
  Память выделяется `динамически`, `по мере необходимости` на каждый элемент внутри. Но `ссылка на объект/массив` будет храниться в `stack`

![[Pasted image 20240313163403.png]]

## _Операторы сравнения_

- `==` Приводит к одному типу и сравнивает (`0 == false`, `5 == '5'`)
- `===` Проверяет сходство типов и значение

## _strick mode_

Улучшает `безопасность` и предвосхищает `совместимость с будущим функционалом` ECMAScript

- `"use strict"` должен быть включен на самой первой строке, иначе не работает
- Нельзя использовать `переменные без объявления`
- `this` не ссылается на глобальный объект
- Если `функция` вызывается `без контекста`(`не как метод объекта`), то `this === undefined`

## _Fn declaration vs Fn expression_

- **Function Declaration** - Объявляется через ключевое `function`. 
  Есть `всплытие` - функцию `можно вызвать до ее объявления`
- **Function Expression** - Функция записывается `в переменную`, `нет всплытия`.

## _function vs arrow-fn_

**Arrow func:**
- Перенимает `контекст родительской функции` в котором была объявлена 
- `Не может` использовать `bind/call/apply`
- Не имеют свойства `prototype`
- Поэтому `не могут выступать конструктором`

## _Hoisting (подъем)_

**Hoisting** -  `Поднимает` `var/fn declaration` вверх `в глобальной` или `функциональной области` видимости. Позволяет `использовать` элементы `до того как они был объявлены` в коде.

`Переменные` `поднимаются` со значением `undefined`, а `function - целиком`

- **Поднятие (hoisting)** - Сканирует код и поднимает `var/fn declaration` вверх.
- **Выполнение** - Код выполняется `построчно`, `постепенно инициализируя`(`присваивая`) значения переменным.

```
console.log(x); /=/ Вывод: undefined
var x = 5;

sayHello(); /=/ Вывод: "Привет!"
function sayHello() {
  console.log("Привет!");
}

sayHello(); /=/ TypeError: sayHello is not a function
var sayHello = function() {
  console.log("Привет!");
}
```

## _Область видимости (Scope)_

**Область видимости** - Это доступные значения.

- **Глобальная** - Доступ из любой части кода
- **Функциональная/Локальная** - Значения доступны только внутри функции
- **Блочная** - Значения доступны `внутри фигурных` скобок `{}`. 
  Применимо только для `let и const`. Переменные `var` `всплывают` до `функцииональной` или `глобальной` области.

![[Pasted image 20240313175256.png]]

## _var let const_

**Поднятие:**
- **var** - `Поднимаются` в своей `области видимости` и `инициализируются` как `undefined`
- **let/const**  - `Поднимаются` в своей `области видимости`, но `не инициализируются`

**Область видимости**
- **var** - `Функциональная область` видимости
- **let/const** - `Блочная область` видимости

**Объявление:**
- **var** - `Переменная может` быть `переобъявлена` и `значение может` быть `обновлено`
- **let** - Только `значение может` быть `обновлено`
- **const** - `Запрещено менять переменную`

## _Временная мертвая зона let/const_

Переменные объявленные через `let/const` `поднимаются в своей области видимости`, как и `var`. `Но не инициализируются` вверху.

**Temporal dead zonde** - Это означает, что:
- `Переменные` будут `созданы` когда `интерпретатор зайдет в область видимости`
- **`Но`** они **`не будут доступны`**, `пока он не дойдет до их` фактического `объявления`.

![[Pasted image 20240318193832.png]]

## _Замыкание_

**Замыкание** - Это `функция` и ее `область видимости` которую она `запоминает при своем вызове`, там где она была написана. 
`Помнит значения` даже если они `более не существуют` или `изменились`. 

```
const createIncrement = (count) => { /=/ 2.Создается функция и count
  const increment = () => { /=/ 6-8-10.Вызовы и увеличение
    count++;
  };
  let message = `Count is ${count}`; /=/ 3.Создается `message === 0`
  const log = () => {
    return message;
  };

  return [increment, log]; /=/ 4.Возврат референсов
};

const [increment, log] = createIncrement(0); /=/ 1.Вызывается функция
increment(); /=/ 5.Вызов increment()
increment(); /=/ 7.Вызов increment()
increment(); /=/ 9.Вызов increment()
log(); // Count is 0
/=/ 11.Вызов log() с созданной `message === 3`
```

- Все `функции` в JS `являются замыканиями`, тк все они `способны запоминать` свое `лексическое окружение` через скрытое свойство `[[Environment]]`.
- Кроме случая создания функции через `new Function()`. При таком создании в ее `[[Enviroment]]` записывается не внешнее лексическое окружение в котором она была создана, а глобальное.

```
function getFunc() {
  let value = "test";
  return new Function('alert(value)');
}

getFunc()(); // Ошибка: value не определено
```
___

![[Pasted image 20240313204642.png]]
Когда `чистая функция` выполняется, она помещается в стек вызовов.
А `внутренние данные` сохраняются только до тех пор, `пока функция не будет удалена из стека` вызовов.
___
![[Pasted image 20240313204818.png]]
Для того чтобы `интерпретатор`(`движок`) мог `вызвать` эту функцию `и узнать значения`  `переменных`, он `сохраняет данные в памяти` в `heap`(`куча`).

Время `хранения` данных `в стеке вызовов` - `недолговечно`. А `куча`(`heap`) способна `хранить` данные в памяти `неограниченное время`. Она `избавляется` от `ненужных данных` с помощью `сборщика мусора`.

```
// var i = undefined

for (var i = 0; i < 3; i++) { 
	let callback = () => {
		console.log(i) 
	}
	
	setTimeout(callback, 0) // 3 3 3
}
```

1. Каждый `цикл` создает `новую функцию` которая `запоминает` ссылку на `var i`.
2. Тк `var i` не фиксируется в блочной области, она `выносится в глобальную`.
3. Цикл проходит и увеличивает `i` до `3`. 
   При этом, `ссылка` на `var i` остается `та же`, но `значение меняется`. Тк цикл не обновляет ссылку на глобальное окружение.
4. `setTimeout()` согласно очереди `Macrotask`, вызывается `после отработки цикла`.
5. Переменная `var i` находилась `в глобальной области`.
   А `цикл` создает новые  `ссылки на окружение` лишь в `блочной среде`,
   Поэтому `замыкание` всегда `запоминало` одну и ту же `глобальную ссылку` на `var i`
6. Теперь выполняются отложенные `setTimeout()`. 
   - Каждое `замыкание` идет в `heap` и берет от туда `сохраненную ссылку` на `i`. 
   - Тк все `ссылки на i одинаковы` и `setTimeout()` выполняется `только после цикла`, а `не в момент каждой итерации` когда значение увеличивается,
     То получается что каждое замыкание:
     1. `Не успело выполнится` во время итерации цикла, когда `значения увеличивались`.
     2. Запомнило `одинаковую ссылку` на глобальную переменную
     Итого, все замыкания:
        - Отложено выполнились когда `цикл закончился` и `i === 3`
        - Сослались на `одинаковую глобальную ссылку` переменной `i`
     3. Все отобразили последнее значение `i`

-> Идентичная запись
```
let i = 0

for(i = 0; i < 3; i++) {
	let callback = () => {
		console.log(i)
	}
	
	setTimeout(callback, 0) // 3 3 3
}
```
___
```
for (let i = 0; i < 3; i++) {
	let callback = () => {
		console.log(i)
	}
	
	setTimeout(callback, 0) // 0 1 2
}
```

- Здесь же `i` `создается` внутри `блочной области`.
- Поэтому, `при каждой итерации`, внутри цикла `создается` `новая переменная` и `новая ссылка` на `i` с иным значением.
- Это позволяет замыканиям запоминать разные ссылки 

## _this_

**this** - вбирает в себя то окружение, в котором его вызывают 

### _this в Глобальном контексте_

При вызове `this` в `глобальном контексте`, он будет ссылаться на `глобальный объект среды` в которой вызывается.

- При запуске в браузере(`script+html`) `this === Window`
```
|> Browser
console.log(this) /=/ Window
```
- При запуске в глобальной среде Node.js, `this` ссылается на `экспорты модуля`
	- Если `модуль ничего не экспортирует`, то `this === {}`
```
|> Node.js

exports.default {
	title: 'Phone'
}
console.log(this) /=/ { default: { title: 'Phone' }} 
```

### _this в Функции_

Внутри обычных `function` значение `this` - ссылается контекст `где функция была создана`.

```
|> Browser

function baz() {
	console.log(this)
}
baz() // Window
```

Тк `функция` была `создана в глобальном` контексте - `this` ссылается `на глобальный` объект.
___

-> `Вложенные функции`
```
|> Browser / Node.js

function baz() { /=/ Берет this из глобального контекста 
	function foo() { /=/ Берет this из baz, у которого this === Window || Global
		console.log(this)
	}
	foo()
}

baz() // Window || Global
```

-> `use strict`
```
|> Browser / Node.js

function baz() {
	console.log(this)
}

baz() // undefined
```

Но при `"use strict"`, у любой среды `глобальный` `this === undefined`

### _this в Методе объекта_

`Метод` получает в качестве `this` - `сам объект`. 
Это позволяет `this обращаться` к `свойствам объекта`

```
const item = {
  title: 'Phone',

  print() {
    console.log(this);
  },
};

item.print() // {title: "Phone", print: print()}
```

### _this в Стрелочных функциях_

У `стрелочных` функций `нет` своего `this`. 
- `Arrow functon` наследует `контекст родительской` функции. 
- Если `нет родительской`, то `делает видё что обернута в function` которая вызывается в `глобальном контексте`.

```
console.log(this); // {}

exports.default = {
  name: "Ann",
};

console.log(this); // { default: { name: 'Ann' } }
```

```
const user = {
  name: "John",
};

function sayHello() {
  /=/ function declaration ссылается на
  /=/ контекст в котором была ВЫЗВАНА
  
	console.log(this); // { name: 'John' }

  /=/ Arrow-func ссылается на 
  /=/ контекст где она была ОПРЕДЕЛЕНА
  const arrowFn = () => {
    return "Hello, " + this.name;
  };
  return arrowFn();
}

console.log(sayHello.call(user)); // Hello, John

/=/ Вызывается в контексте объекта user
/=/ Как если бы у user был метод `user.sayHello()`
```

```
function sayHello2() {
  console.log(this); // Object [global]

  const arrowFn = () => {
    return "Hello, " + this.name;
  };
  return arrowFn();
}

console.log(sayHello2()); // Hello, undefined
/=/ Вызывается неявно как `global.sayHello2()`
/=/ Но тк у global нет свойства name, то undefined

global.name = "myValue";
console.log(sayHello2()); // Hello, myValue
```

### _this в Функциях-Конструкторах_

Через конструктор `new FunctionName()` создаем экземпляр объекта.
`this` ссылается на `поля этого объекта`.

```
function Func(name, price) {
  this.name = name;
  this.price = price;
  return this
}
console.log(new Func('tool', 1000)) /=/ Func {name: "tool", price: 1000}
```

### _Привязка контекста к функции_

- **.call(thisObj, arg1, arg2, ...)** `|` **.apply(thisObj, `[arg1, arg2, ...]`)**  
  `Привязывают контекст` для `вызова функции`. `Вызов` функции происходит `сразу`.
- **.bind()** - Возвращает `новую функцию` с `привязанным` для вызова `контекстом`.

```
const max = { name: 'Max', debt: 3000 };
const alex = { name: 'Alex', debt: 0 };

function greet(...args) {
  if (this.debt) {
    console.log(this.debt);
  } else {
    console.log(`Hello ${this.name}! ${args}`);
  }
}

greet.call(max, threats[0], threats[1]);
greet.apply(max, threats);

const alexGreet = greet.bind(alex, threats); 
alexGreet()
```

## _Функции - объекты первого класса?_

**Функции первого класса** - имеют те же `возможности` что и у `объектов` и `массивов`

**Функции** в JS это `объекты первого класса`, тк можно:
1. Записать `функции в переменную`
```
function greet(name) {
  console.log("Hello, " + name + "!");
}

const myFunc = greet;
myFunc(); 
```
2. Передать `функцию как аргумент`
3. Вернуть `из функции функцию`
4. Сохранить `функцию в структуре данных`
```
const functionArray = [
  function greet(name) {
    console.log("Hello");
  },
  function sayBye(name) {
    console.log("Goodbye");
  }
];

functionArray[0]();
functionArray[1]();
```

## _IIFE_

**IIFE (Immediately Invoked Function Expression)** - `Немедленный вызов` функции. Самовызывающаяся анонимная функция.

```
(function () {
  console.log("call");
})();
```

## _Псевдомассив vs массив_

- Псевдомассив `не имеет методов` массива
- Могут содержать `числовые индексы` для получения свойств 
- Может содержать свойство `length`
- Не является экземпляром `Array`

```
const pseudoArray = { 0: "a", 1: "b", length: 2 };

pseudoArray[0]; // 'a'
pseudoArray.length; // 2
```

Псевдомассив можно получить из `.querySelectorAll()` или `Function.arguments()`

## _Прототипное наследование_

**Прототипное наследование** - Позволяет `наследовать` свойства `базового класса`. 
С помощью `прототипного наследования` происходит `поиск методов вверх по иерархии`.

- **prototype** - `Содержит свойства и методы` которые будут `унаследованы от конструктора`. 
- **__proto__** - `Ссылается на родительский конструктор`. Имеется `у каждого объекта`. 

-> `Встроенные прототипы
```
console.log(Object.prototype); /=/ Встроенные прототип Объекта
console.log(Promise.prototype);
console.log(Function.prototype);
console.log(Boolean.prototype);
console.log(Number.prototype);
console.log(String.prototype);
console.log(Array.prototype);
```
-> `Кастомные прототипы`
```
class ClassComponent {}
function FuncComponent() {}

ClassComponent.prototype !== FuncComponent.prototype 
ClassComponent.__proto__ === Function.prototype; // true
FuncComponent.__proto__  === Function.prototype; // true
```

## _autoboxing_

**Автоматическое оборачивание** - Происходит `в момент обращения к` свойствам `примитива`. 
- Примитив `временно преобразуется в объект` для `доступа к методам` родительского конструктора.
- `После выполнения` операции, преобразование `отбрасывается` 

## _Обход свойств объекта и прототипа_

- **`for...in` / `in`** - Проходит по свойствам `объекта и прототипа`
- **`hasOwnProperty`** и **`.keys()`** - Проходят `только` по свойствам `объекта`

## _Пример мемоизации_

```
const memo = (fn, cache = new Map()) => (...args) => {
  const key = JSON.stringify(args)

  if (!cache.get(key)) {
    cache.set(key, fn.apply(this, args))
  }
  return cache.get(key)
}

const func = memo((x, y) => x * Math.sin(1 / x));
func(0.314, 5);
func(0.314, 5);
```

## _Object.freeze() и Object.seal()_

![[Pasted image 20240316135709.png]]

## _Динамическая vs статическая типизация_

**Статическая типизация**:
- `Проверка` типов данных происходит `во время компиляции`, а не во время выполнения
- `Типы` данных обычно объявляются `явно и один раз`, не меняя тип в процессе.

## _Полифил_

- **Полифил** - `иная реализация` функционала `кода`, как правило `для поддержания совместимости` со старыми браузерами

## _Set/Map/Weak_

- **new Set()** - Создает `уникальную коллекцию` `значений любого типа`. Не допускает дублирования. Принимает `массив массивов`.
- **WeakSet/Map** - Используется `для создания слабых ссылок на объекты`. Так например, если `объект нигде кроме Weak не используется`, то `удаляется сборщиком`.

```
map => new Map([
  ["Hi", "Привет"],
  [42, "Автостопом по галактике"],
  [true, false],
  [{}, "Объект"],
  [function () {}, "Функция"]
]);
_____________________
map = new Map();
map.set("Hi", "Привет")
	 .set("42", "42")
	 .set(42, 42)

console.log(map); /=/ Map { 'Hi' => 'Привет', '42' => '42', 42 => 42 }
```

## _Map vs Object_

**Map**
- Использует `любые элементы` в качестве `key`
- `Ключи` хранятся `в порядке добавления`.
- По Map `можно итерироваться` как по массиву

```
const map = new Map([["a", 1], ["b", 2], ["c", 3]]);

map.forEach((value, key) => {
  console.log(key, value);
});
```

## _Каррирование_

**Каррирование** - позволяет `заменить` вызов `функции со множеством аргументов` на` HOF с вложенными функциям`и внутри. Которые можно `вызывать постепенно`, работают `за счет замыкания`

```
function curry(fn) {
  return function (a) {
    return function (b) {
      return fn(a, b);
    };
  };
}

const add = (a, b) => a + b;

const curriedAdd = curry(add);
curriedAdd(1)(2); // 3
```

## _Сборка мусора_

В большинстве случаев используется алгоритм `Mark and Sweep`.
Помечает живые объекты, удаляет все остальное

- **Мусор** - То что `не является живым объектом` 
- **Живой объект** - `Тот` `до которого` можно `дойти` по ссылкам `от корневого объекта`

## _Утечка памяти_

- **Циклические ссылки** - Объекты ссылаются друг на друга.
- **Таймеры** и **Слушатели событий**
- **Глобальные переменные**
- **Замыкания**

## _Контекст выполнения_

**Типы** контекста выполнения:
- **Глобальный** - Доступен для всех, `создается сразу`
- **Функциональный** - Локальный `контекст внутри функции`, создается `при вызове функции`

**Этапы создания** контекста выполнения:
1. Создание `объекта с переменными`(`лексическое окружение`)
2. Создание `областей видимости`(`локальные переменные + ссылки внешние области`)
3. Определение `контекста выполнения` для `this`(`window.fn() / obj.fn()`)

## _Глубокое копирование_

- `JSON.stringify()` - `Не способен` сериализовать `функции` , `Map`, `Set`
- `window.structuredClone()` - Предназначен для глубокого копирования. Поддерживает `Map`, `Set`. 
- `Рекурсия` + `...spread` 

## _Декоратор_

**Декоратор** - Цель `расширить функционал` сверх функционала `функции/объекта`

## _Proxy_

**Proxy** - Цель `ограничить доступ` к  `функции/объекту`. `Перехватывает чтение полей` и их `запись`. 

## _Асинхронность_

**Асинхронность** - `Выполнение кода параллельно/в фоне`, `не блокируя основной поток` кода. 

Хоть `JS` и `однопоточен`, но `параллельная асинхронность возможна` за счет механизмов `EventLoop` и `WebWorkers`. 
В обоих случаях `дополнительный поток` берется из `делегирования` кода `среде выполнения`(`Browser/Node.js`)

## _Синхронные vs асинхронные функции_

- **Синхронные** - `Блокируют продвижение` кода до тех пор `пока функция не выполнится`.

**Асинхронный код:**
- `async function`
- `Callback / Promise`
- `Браузерное API`
	- `Timer`
	- `eventListener`

## _AJAX_

**AJAX** - `Асинхронные запросы` без блокировки или `перезагрузки` страницы. 
Позволяют `получать/отправлять данные` с сервера в формате `XML/JSON`.

**Плюсы:**
- `Отзывчивость страницы` без перезагрузок
- `Сохранение состояния значений` страницы
- `Уменьшение нагрузки` на сервер

**Минусы:**
- `Не работает при заблокированном JS` в браузере
- `Проблема с индексацией` и `SEO`

```
fetch("https://jsonplaceholder.typicode.com/todos/1", {
  method: "POST",
  body: JSON.stringify({
    title: "foo",
  }),
  headers: { "Content-type": "application/json; charset=UTF-8" },
});
```

## _EventLoop_

**EventLoop** - бесконечный цикл, который ожидает задачи и выполняет их

![[Pasted image 20240317200135.png]]

- **JS движком**  чаще всего является движок **`V8`**
	- **`Движок JS`** предоставляет **`CallStack`**(`стопка вызовов`) и **`Heap`**
- **EventLoop** `предоставляется средой`, а `не движком`(**`Browser, Node.js`**). Поэтому `устройство EventLoop` может `быть` реализовано `различно`.
	- **`EventLoop`** предоставляет **`Очередь задач`**(`micro/macroTask`)
- **WebAPI** - Связующее `звено` между `CallStack` и `TaskQueue`
	- `Обрабатывает` в себе `ожидание таймера` => отправляет `cb таймера` в `TaskQueue`
	- `Регистрирует` в себе `eventListener`, аналогично `отправляет при срабатывании`.
___

**Очередность выполнения:**
1. Выполняется `весь синхронный` обычный `код`
2. Выполняются `все microTask`
3. Берется `одна macroTask` и выполняется
- `Перед тем как выполнить` следующую `macroTask` - `проверяется` наличие `microTask`!

```
console.log("log 1");

setTimeout(() => {
  console.log("log 2");

  Promise.resolve().then(() => {
    console.log("log 3");
  });
}, 0);

setTimeout(() => {
  console.log("log 4");
}, 0);

Promise.resolve().then(() => {
  console.log("log 5");
});

console.log("log 6");

/=/ log 1
/=/ log 6
/=/ log 5
/=/ log 2
/=/ log 3
/=/ log 4
```

**Микротаски:**
- **Promise**, **then/catch/finally**
- **queueMicrotask()** - Добавляет `функцию в` очередь `microTask`
- **Изменения DOM**(`MutationObserver`) - Позволяет `следить` за изменениями `DOM`

## _Promise_

**Promise** - `Дождется` и `вернет результат`, когда код выполнится. 

`Возвращает` объект `Promise` для возможности обращения к нему `.then()/.catch()`. Они в свою очередь аналогично возвращают объект `Promise` для возможности создания цепочек. 

**fetch** - `Использует внутри` механизмы `Promise` 

```
function loadData(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onload = () => {
      if (xhr.status === 200) {
        resolve(xhr.responseText);
      } else {
        reject(new Error(`Error: ${xhr.status}`));
      }
    };
    xhr.onerror = () => reject(new Error('Network request failed'));
    xhr.send();
  });
}

// Пример использования
loadData('https://api.example.com/data')
  .then((response) => {
    console.log('Данные успешно загружены:', response);
  })
  .catch((error) => {
    console.error('Ошибка загрузки данных:', error);
  });
```

- **Promise.all(`[...promise's]`)** - Принимает массив промисов. Возвращает Promise, который `разрешается когда все промисы будут выполнены`. Или `reject, если хотя бы один упал`.
- **Promise.rase(`[...promise's]`)** 
- **Promise.any(`[...promise's]`)** - Разрешается если `хоть кто-то выполнился`. `Reject` если `все промисы упали`.

- **Promise.allSettled(`[...promise's]`)** - `Дожидается выполнения/отклонения всех` промисов. `Возвращает массив объектов` со свойствами `status` и `value/reason`
  
```
const promises = [
  Promise.resolve("Успех"),
  Promise.reject("Ошибка"),
  Promise.resolve("Еще один успех"),
];

Promise.allSettled(promises).then((results) => console.log(results));
// [
//   { status: 'fulfilled', value: 'Успех' },
//   { status: 'rejected', reason: 'Ошибка' },
//   { status: 'fulfilled', value: 'Еще один успех' }
// ]
```


**Преимущество `Promise` перед `callback`:**
- Избежание `callback-hell`
- `Читаемость` кода за счет `последовательной цепочки` `.then()`
- `Упрощает параллельные запросы` через `Promise.all()`

## _async/await_

**async function** - Это `синтаксический сахар`, `внутри` работают на `Promise`. Возвращают `Promise`.

![[Pasted image 20240318154238.png]]

## _Итератор / генератор_

- **Итератор** - **`Интерфейс`** с методом `next()`, со `значением` и `признаком конца` `done`
  Это `объект` с `методом` `next()`, который `возвращает { value, done }`
  -> `Загрузили` `DB` и с помощью метода `next()` `двигаемся по` этой `коллекции`.
- **Генератор** - **`Подход`**, который `вычисляет` только `следующий элемент`.
  `Генератор` `возвращает` в себе `итератор`. 
  -> `Не загружаем целиком` `DB`, а каждое `значение вычисляем после` вызова `next()`

```
const iterator = ["a", "b"][Symbol.iterator]();
```

```
iterator.next(); /=/ { value: 'a', done: false }
iterator.next(); /=/ { value: 'b', done: false }
iterator.next(); /=/ { value: undefined, done: true }
```

Обращение `к Symbol свойству массива` - `возвращает генератор`. 
А `генератор` при вызове - `возвращает итератор`.
А у `итератора` есть `метод` `next()` для перемещения по элементам.

```
function* generator() {
  yield "a";
  yield "b";
}

const iterator = generator();

console.log(iterator.next()); /=/ { value: 'a', done: false }
console.log(iterator.next()); /=/ { value: 'b', done: false }
console.log(iterator.next()); /=/ { value: undefined, done: true }
```
___

```
function* makeGenerator(start = 0, end = 2, step = 1) {
  let iterCount = 0;

  for (let i = start; i < end; i += step) {
    iterCount++;
    yield i; 
    /=/ Возвращает значение для текущего next() 
    /=/ И останавливает выполнение функции до следующего next()
  }

  return `Итог: ${iterCount}`; 
  /=/ Возвращает итоговый результат функции после отработки всех next()
}

const iterator = makeGenerator();

iterator.next(); /=/ { value: 0, done: false }
iterator.next(); /=/ { value: 1, done: false }
iterator.next(); /=/ { value: 'Итог: 2', done: true }
iterator.next(); /=/ { value: undefined, done: true }
```

**Ленивая загрузка данных**: Генераторы могут быть эффективны для загрузки данных из внешних источников ленивым образом, то есть по мере необходимости. Например, если у вас есть массив данных, который слишком велик, чтобы загружать его целиком в память, вы можете использовать генератор для загрузки элементов по мере необходимости.

```
function* lazyLoadData(array) {
  for (let i = 0; i < array.length; i++) {
    yield array[i]; // Возвращаем элемент массива по мере необходимости
  }
}

const bigDataArray = [1, 2, 3, 4, 5, /* ... очень много элементов ... */];

const iterator = lazyLoadData(bigDataArray);

/=/ Предположим, что мы хотим загрузить только первые 3 элемента
for (let i = 0; i < 3; i++) { 
  const nextItem = iterator.next();

	/=/ Проверяем, не достигнут ли конец последовательности
	if (!nextItem.done) { 
    console.log("Загружен элемент:", nextItem.value);
  } else {
    console.log("Достигнут конец последовательности.");
    break;
  }
}
```

## _Плюсы/минусы асинхронного программирования_

**Плюсы:**
- **Отзывчивость интерфейса**
  Позволяет `выполнять несколько операций параллельно`, а `не ждать каждую`.
- **Сбоеустойчивость запросов**
  `Сбой одного` потока `не влияет на другие`
- **Улучшение пользовательского опыта**
  За счет возможности `динамически подгружать контент`(`отсутствие перезагрузок`) 
  и `выполнять запросе в фоновом режиме`. 
  
**Минусы:**
- `Задержка` при `первичной загрузке` начальной страницы
- Код может быть `неочевиден` в последовательности `во время отладки`.
- `Трудность индексирования` контента
- **Race condition (состояние гонки)** - Несколько операций борятся за один и тот же ресурс. `Победить` может `не самый последний запрос`, это выдаст некорректный результат

## _MutationObserver_

**MytationObserver** - `Наблюдает` и `реагирует после изменения` в `DOM`.  

```
const box = document.querySelector('.box');

/=/ Создаем наблюдатель
const observer = new MutationObserver(mutationRecords => {
    console.log(mutationRecords);
});

/=/ Запускаем отслеживание
observer.observe(box, { childList: true });
```

## _ECMAScript_

**ECMAScript** - Это `спецификация`, стандарт и `набор правил для языка` JS

## 