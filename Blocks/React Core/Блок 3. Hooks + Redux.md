## _Hooks - Правила и ограничения хуков_

1. **Хуки** `нельзя` вызывать в `условиях` и в `циклах`.
   Тк при каждом рендере хуки `должны вызываться` каждый раз `в одинаковой последовательности`. (например `useState()`)
2. **Хуки** должны вызываться только `на верхнем уровне` в `функциональных компонентах` или в `custom-ных хуках`.
   ` Не могут` вызываться `в обычных функциях,` тк React `связывает состояние` хука с конкретных `экземпляром` компонента.

## _Redux_

Использование `Redux` должно соответствовать подходу `функционального программирования`

### _Функциональное программирование_

![[Func programming]]

## _store/action/dispatch/reducer_

<img src="https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif" >

### _Store (`хранилище`)_

- **Определение:** Хранилище - объект, который `содержит состояние` всего приложения.
- **Функции:**
  - `Хранение` текущего `состояния` приложения.
  - Позволяет `get`(`получать`) текущее `состояние` с помощью `getState()`.
  - Позволяет `dispatch`(`отправлять/обновлять`) `состояние` с помощью `dispatch(action)`.
  - Позволяет `subscribe`(`добавлять слушателей`) для `отслеживания изменений` состояния.

```
import { createStore } from 'redux';

const store = createStore(counterReducer);
```

`subscribe` используется для `регистрации функции обратного вызова`, которая будет `вызываться` каждый раз, `когда` происходит `изменение состояния`.
Функция `callback` будет получать `текущее состояние` в качестве аргумента.

```
const store = createStore(reducer);

const handleChange = () => {
  const currentState = store.getState();
  console.log('Current state:', currentState);
};

const unsubscribe = store.subscribe(handleChange);

/=/ Вызовите unsubscribe, чтобы отменить подписку
// unsubscribe();

/=/ Когда происходит изменение состояния, handleChange будет вызываться
```

### _Action (`действие`)_

- **Определение:** Действие - это объект, который `описывает изменение состояния` в приложении. Это единственный способ изменения состояния в Redux.
- **Структура:** `{ type: 'НАЗВАНИЕ_ДЕЙСТВИЯ', payload: данные }`
  - `type` - что необходимо сделать
  - `payload` - `вспомогательные данные` которые необходимы для того чтобы `найти`
    и/или `установить` новые данные, и после чего `изменить` `state`.

```
const incrementAction = {
  type: 'INCREMENT',
  payload: 5,
};

store.dispatch(incrementAction);
```

**Нейминг** `actions` происходит `обратным методом`, в виде `совершенного действия`.
Например: Да: `taskCompleted` | Нет: `completeTask`

### _Dispatch (`отправка`)_

- **Определение:** Отправка - это метод `хранилища`(`store`), используемый `для отправки действия`(`action`) в хранилище. Он `инициирует процесс изменения состояния`.

```
store.dispatch(incrementAction);
```

Когда метод `dispatch` вызывается, `хранилище`(`store`) передает `действие`(`action`)
`обработчику`(`reducer`), который `возвращает новое состояние`. Подписчики хранилища, такие как компоненты React, могут быть уведомлены об изменении состояния, чтобы обновить пользовательский интерфейс.

### _Reducer (`обработчик`)_

- **Определение:** Обработчик - это `чистая функция`, которая `принимает предыдущее состояние` и `действие`, и `возвращает новое состояние`.
- **Структура:** `(state, action) => newState`

```
const counterReducer = (state = 0, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return state + action.payload;
    case 'DECREMENT':
      return state - action.payload;
    default:
      return state;
  }
};
```

Функции `Reducer` получили свое название, потому что они похожи на функцию обратного вызова, которую вы передаете методу `Array.reduce()`.

### _Процесс обновления состояния_

1. **Создание действия:** Создается объект действия с определенным типом и данными (при необходимости).
2. **Отправка действия:** Действие отправляется в хранилище с помощью функции `dispatch`.
3. **Вызов редьюсера:** Редьюсер обрабатывает действие и возвращает новое состояние.
4. **Обновление состояния:** Хранилище обновляет свое состояние согласно результатам работы редьюсера.
5. **Уведомление подписчиков:** Зарегистрированные слушатели получают уведомление о изменении состояния.

```
/=/ Определение редьюсера
const counterReducer = (state = 0, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return state + action.payload;
    case 'DECREMENT':
      return state - action.payload;
    default:
      return state;
  }
}

/=/ Создание хранилища
const store = createStore(counterReducer);

/=/ Регистрация слушателя для отслеживания изменений состояния
store.subscribe(() => {
  console.log(store.getState()); /=/ Выведет обновленное состояние
});

/=/ Создание действия и отправка в хранилище
const incrementAction = {
  type: 'INCREMENT',
  payload: 5,
};
store.dispatch(incrementAction);
```

## _Воссоздание Redux_

```
import { useState, useEffect } from "react";

const TASK_ADDED = "tasks/added";
const TASK_UPDATED = "tasks/updated";

function taskReducer(state, action) {
  switch (action.type) {
    case TASK_UPDATED:
      return state.map((task) => {
        return task.id === action.payload.id
          ? { ...task, ...action.payload }
          : task;
      });
    case TASK_ADDED:
      return [...state, action.payload];

		default:
      return state;
  }
}

function createStore(reducer, initState) {
  let state = initState;
  let listeners = [];

  function getState() {
    return state;
  }

  function dispatch(action) {
    state = reducer(state, action);
    listeners.forEach((listener) => listener());
    // Notify all listeners that the state has changed.
  }

  function subscribe(listener) {
    listeners.push(listener);
  }

  return { getState, dispatch, subscribe };
}

const initState = [
  { id: 1, title: "Task 1", completed: false },
  { id: 2, title: "Task 2", completed: false },
];
const store = createStore(taskReducer, initState);

const App = () => {
  const [state, setState] = useState(store.getState());

  useEffect(() => {
    store.subscribe(() => {
      setState(store.getState());
      console.log(store.getState());
    });
  }, []);

  const completeTask = (taskId) => {
    const action = {
      type: TASK_UPDATED,
      payload: { id: taskId, completed: true },
    };
    store.dispatch(action);
  };

  const changeTitle = (taskId) => {
    const action = {
      type: TASK_UPDATED,
      payload: { id: taskId, title: `New Title ${taskId}` },
    };
    store.dispatch(action);
  };

  const addTask = () => {
    const action = {
      type: TASK_ADDED,
      payload: {
        id: Date.now(),
        title: "New Task",
        completed: false,
      },
    };
    store.dispatch(action);
  };

  return (
    <>
      <h1>App</h1>
      <p />
      {state.map((task) => (
        <li key={task.id}>
          <span>{task.title}</span>
          <span> {task.completed ? "✅" : "❌"}</span> <p />
          <button onClick={() => completeTask(task.id)}>Complete</button>{" "}
          <button onClick={() => changeTitle(task.id)}>Change Title</button>{" "}
          <hr />
        </li>
      ))}
      <button onClick={addTask}>Add Task</button>
    </>
  );
};

export default App;
```

## _Redux-toolkit_

### _bindActionCreators_

**bindActionCreators** помогает автоматически связывать действия (`actions`) с функцией отправки (`dispatch`)

-> Воссоздание внутреннего функционала

```
const bindActionCreator = (creator, dispatch) => {
  return (...args) => {
    dispatch(creator(...args));
  };
};

const taskCompletedDispatch = bindActionCreator(taskCompleted, dispatch);

const handleTaskComplete = (id) => {
  taskCompletedDispatch(id);
};
```

-> Полноценный функционал

```
import { bindActionCreators } from "redux";
import { initStore, actions } from "./store";

const { taskCompleted, titleChanged } = bindActionCreators(actions, dispatch);

const handleTaskComplete = (id) => {
  taskCompleted(id);
};

const handleTitleChange = (id) => {
	titleChanged(id);
};
```

### _createAction()_

```
/=/ Стало:
const add = createAction("tasks/added");

export const taskCompleted = (id) => {
  return update({ id: id, completed: true });
};

/=/ Было:
const TASK_UPDATED = "tasks/added"

export const taskCompleted = (id) => {
  return {
    type: TASK_UPDATED,
    payload: { id: id, completed: true },
  };
};
```

### _createReducer()_

```
const initialState = [
  { id: 1, title: "Task 1", completed: false },
  { id: 2, title: "Task 2", completed: false },
];

const taskReducer = createReducer(initState, (builder) => {
  builder
    .addCase(add, (state, action) => {
      state.push(action.payload);
    })
    .addCase(update, (state, action) => {
      return state.map((task) => {
        return task.id === action.payload.id
          ? { ...task, ...action.payload }
          : task;
      });
    });
});
```

- Используйте `return`, когда вы хотите вернуть новое состояние, основанное на предыдущем состоянии и действии.

```
.addCase(update, (state, action) => {
  return { ...state, ...action.payload };
})
```

- Не используйте `return`, когда вы изменяете состояние напрямую, без возвращения нового значения.

```
.addCase(add, (state, action) => {
  state.push(action.payload);
})
```

### _createSlice()_

Внутри он использует `createAction` и `createReducer`.

```
import { createSlice } from "@reduxjs/toolkit";

const initialState = [
  { id: 1, title: "Task 1", completed: false },
  { id: 2, title: "Task 2", completed: false },
];

const taskSlice = createSlice({
  name: "tasks",
  initialState,
  reducers: {
    add(state, action) {
      state.push(action.payload);
      console.log(action); // { type: 'tasks/add', payload: { id: 3, ... } }
    },
    update(state, action) {
      return state.map((task) => {
        return task.id === action.payload.id
          ? { ...task, ...action.payload }
          : task;
      });
    },
    remove(state, action) {
      return state.filter((item) => {
        return item.id !== action.payload.id;
      });
    },
  },
});

const { reducer: taskReducer } = taskSlice;
const { add, update, remove } = taskSlice.actions;

export const taskCompleted = (id) => {
  return update({ id: id, completed: true });
};

export const titleChanged = (id) => {
  return update({ id: id, title: `New Title ${id}` });
};

export const taskAdded = () => {
  return add({ id: Date.now(), title: "New Task", completed: false });
};

export const taskDeleted = (id) => {
  return remove({ id: id });
};
```

### _Middleware. Логгер/Перехватчик_

```
|> store.js

import { configureStore } from "@reduxjs/toolkit";
import taskReducer from "./task";
import logger from "./middleware/logger";

const initStore = () => {
  return configureStore({
    reducer: taskReducer,
    middleware: (getDefaultMiddleware) => [...getDefaultMiddleware(), logger],
  });
};

export default initStore;
```

```
|> logger.js

const logger = (store) => {
  return function wrapDispatch(next) {
    return function handleAction(action) {
			console.log(store); // {getState: ƒ, dispatch: ƒ}
			console.log(next); // λ:dispatch
			console.log(action); // {type:'tasks/update',payload:{id:1, completed:true }}

			/=/ Перехватываем и переназначаем action
      if (action.type === "tasks/remove") {
        store.dispatch({
          type: "tasks/add",
          payload: {
            id: Date.now(),
            title: "Task Middleware",
            completed: false,
          },
        });
        console.log("Added a new task");

        return; 
        /=/ Останавливаем локальное распространение ранее назначенного actions
      }
      
      return next(action); 
      /=/ Позволяет распространятся следующим actions
      /=/ Если не возвращать, то actions не работают
    };
  };
};

export default logger;
```