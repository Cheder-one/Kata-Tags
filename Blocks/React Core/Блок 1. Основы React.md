**React** - это `open source` `библиотека`, разработанная Facebook. Это не фреймворк, тк `React` отвечает только за `UI компоненты`. Использует язык `JSX` и алгоритм `Reconciliation`. 

Алгоритм `Reconciliation` - это процесс сравнения `предыдущего состояния` компонента с `новым состоянием` и `накопления` необходимого набора `изменений`, которые нужно `применить к DOM` для обновления пользовательского интерфейса.

## _React on Classes_

```
import React, { Component } from 'react';

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  increment = () => {
    this.setState(prevState => ({
      count: prevState.count + 1
    }));
  };

  decrement = () => {
    this.setState(prevState => ({
      count: prevState.count - 1
    }));
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
        <button onClick={this.decrement}>Decrement</button>
      </div>
    );
  }
}

export default Counter;
```

1. **Наследование от `Component`:**
   В React компоненты могут быть созданы двумя основными способами: с использованием функциональных компонентов и с использованием классов. Когда вы создаете компонент на основе класса, вы наследуетесь от базового класса `React.Component`, предоставляемого библиотекой React. Этот класс предоставляет базовую реализацию многих методов, необходимых для работы с компонентами, таких как методы жизненного цикла (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`, и так далее).
2. **Методы и функции**
   В вашем примере методы `increment` и `decrement` написаны в виде стрелочных функций класса. Это современный синтаксис JavaScript, который также сохраняет контекст `this`. Стрелочные функции автоматически привязывают контекст выполнения к контексту, в котором они были созданы, и в данном случае, это экземпляр класса `Counter`.
   Другие методы, такие как `render`, являются членами класса и пишутся в традиционной форме, не как стрелочные функции. Они автоматически наследуют контекст, и в большинстве случаев это то, что вам нужно.

-> Этот же код через функциональный React
```
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  const decrement = () => {
    setCount(count - 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </div>
  );
}

export default Counter;
```

### _Пример связанных Классовых компонентов_

```
import React, { Component } from 'react';

class Header extends Component {
  render() {
    return (
      <div>
        <h1>{this.props.title}</h1>
      </div>
    );
  }
}

class Content extends Component {
  render() {
    return (
      <div>
        <p>{this.props.content}</p>
      </div>
    );
  }
}

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      title: 'My React App',
      content: 'Welcome to my React application!'
    };
  }

  render() {
    return (
      <div>
        <Header title={this.state.title} />
        <Content content={this.state.content} />
      </div>
    );
  }
}

export default App;

```

- Компонент `Header` и `Content` принимают данные через `props` и отображают их.
- Компонент `App` содержит общее состояние `title` и `content`, которое передается в дочерние компоненты через `props`.
- Обновление состояния в компоненте `App` будет автоматически передаваться дочерним компонентам, что приведет к их перерисовке.

### _Избежать написания `this`_

```
render() {
  return (
    <div>
			<Header title={this.state.title} />
			<Content content={this.state.content} />
    </div>
  );
}

render() {
  const { title, content } = this.state;
  return (
    <div>
      <Header title={title} />
      <Content content={content} />
    </div>
  );
}
```

