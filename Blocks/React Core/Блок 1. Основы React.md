**React** - это `open source` `библиотека`, разработанная Facebook. Это не фреймворк, тк `React` отвечает только за `UI компоненты`. Использует язык `JSX` и алгоритм `Reconciliation`.

Алгоритм `Reconciliation` - это процесс сравнения `предыдущего состояния` компонента с `новым состоянием` и `накопления` необходимого набора `изменений`, которые нужно `применить к DOM` для обновления пользовательского интерфейса.

## _React on Classes_

![[Pasted image 20231124003047.png]]

![[Pasted image 20231124004001.png]]
`Корректировка: должно быть this.props.name и this.props.age`

```
import React, { Component } from 'react';

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  increment = () => {
    this.setState(prevState => ({
      count: prevState.count + 1
    }));
  };

  decrement = () => {
    this.setState(prevState => ({
      count: prevState.count - 1
    }));
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={this.increment}>Increment</button>
        <button onClick={this.decrement}>Decrement</button>
      </div>
    );
  }
}

export default Counter;
```

1. **Наследование от `Component`:**
   В React компоненты могут быть созданы двумя основными способами: с использованием функциональных компонентов и с использованием классов. Когда вы создаете компонент на основе класса, вы наследуетесь от базового класса `React.Component`, предоставляемого библиотекой React. Этот класс предоставляет базовую реализацию многих методов, необходимых для работы с компонентами, таких как методы жизненного цикла (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`, и так далее).
2. **Методы и функции**
   В вашем примере методы `increment` и `decrement` написаны в виде стрелочных функций класса. Это современный синтаксис JavaScript, который также сохраняет контекст `this`. Стрелочные функции автоматически привязывают контекст выполнения к контексту, в котором они были созданы, и в данном случае, это экземпляр класса `Counter`.
   Другие методы, такие как `render`, являются членами класса и пишутся в традиционной форме, не как стрелочные функции. Они автоматически наследуют контекст, и в большинстве случаев это то, что вам нужно.

-> Этот же код через функциональный React

```
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  const decrement = () => {
    setCount(count - 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </div>
  );
}

export default Counter;
```

### _Пример связанных Классовых компонентов_

```
import React, { Component } from 'react';

class Header extends Component {
  render() {
    return (
      <div>
        <h1>{this.props.title}</h1>
      </div>
    );
  }
}

class Content extends Component {
  render() {
    return (
      <div>
        <p>{this.props.content}</p>
      </div>
    );
  }
}

class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      title: 'My React App',
      content: 'Welcome to my React application!'
    };
  }

  render() {
    return (
      <div>
        <Header title={this.state.title} />
        <Content content={this.state.content} />
      </div>
    );
  }
}

export default App;

```

- Компонент `Header` и `Content` принимают данные через `props` и отображают их.
- Компонент `App` содержит общее состояние `title` и `content`, которое передается в дочерние компоненты через `props`.
- Обновление состояния в компоненте `App` будет автоматически передаваться дочерним компонентам, что приведет к их перерисовке.

### *[[this#*Потеря контекста*]]*

### _3 способа получить `props`_

```
class TaskInputForm extends Component {
  constructor(props) {
    super(props);
    this.props = props;
    this.state = { inputValue: "" };
  }

  render() {
    return (
      <header className="header">
        <h1>{this.props.title}</h1>
        <input
          className="new-todo"
          placeholder="What needs to be done?"
          autoFocus
        />
      </header>
    );
  }
}
```

```
class TaskInputForm extends Component {
	this.state = { inputValue: "" };

  render() {
    return (
      <header className="header">
        <h1>{this.props.title}</h1>
        <input
          className="new-todo"
          placeholder="What needs to be done?"
          autoFocus
        />
      </header>
    );
  }
}
```

```
class TaskInputForm extends Component {
	this.state = { inputValue: "" };

  render() {
    const { title } = this.props;
    // const p = this.props;

    return (
      <header className="header">
        <h1>{title}</h1>
        <input
          className="new-todo"
          placeholder="What needs to be done?"
          autoFocus
        />
      </header>
    );
  }
}
```

## _`key` в React_

**Ключи** предназначены для `улучшения производительности` при `отрисовке` элементов.
Вместо того чтобы сравнивать состояния элементов `первый с первым`, `второй со вторым` и ошибочно перерисовывать весь список целиком, тк первый элемент сдвинул все остальные

![[Pasted image 20231124205921.png]]

React использует `неизменные ключи элемента`, по которым он ориентируется и `точечно` понимает что пропало, а что появилось и `отрисовывает` только необходимое.

![[Pasted image 20231124210003.png]]

## _Принципы философии React_

Философия React включает в себя набор принципов и правил, которые помогают разработчикам создавать эффективные и понятные компоненты. Ниже приведен перечень основных правил и подходов, которые часто рекомендуются в разработке на React:

1. **Принцип единственной ответственности (Single Responsibility Principle):**
   Каждый компонент должен быть ответственен только за одну вещь. Это упрощает понимание кода и его поддержку.
2. **Принцип контролируемого компонента (Controlled Components):**
   Используйте управляемые компоненты, где состояние компонента контролируется через его пропсы. Изменение состояния должно происходить только через вызовы функций обратного вызова.
3. **Независимость компонентов (Component Independence):**
   Компоненты должны быть независимыми друг от друга. Каждый компонент должен иметь свою логику и состояние, не зависящие напрямую от других компонентов.
4. **Пропсы для передачи данных (Props for Data Flow):**
   Используйте пропсы для передачи данных между компонентами. Избегайте прямого доступа к состоянию других компонентов.
5. **Использование жизненных циклов с умом (Lifecycles Usage):**
   Правильно используйте методы жизненного цикла компонентов для выполнения различных задач, таких как инициализация, обновление и очистка ресурсов.
6. **Избегайте напрямую изменять DOM (Avoid Direct DOM Manipulation):**
   Используйте состояние и пропсы React для управления содержимым DOM. Избегайте прямых манипуляций DOM вне методов жизненного цикла.
7. **Композиция компонентов (Component Composition):**
   Стремитесь к созданию маленьких и переиспользуемых компонентов, которые можно комбинировать в более крупные, используя композицию.
8. **Поддержка читаемости кода (Code Readability):**
   Следуйте принципам хорошего стиля кода и форматирования. Используйте понятные имена переменных и функций, разбивайте код на читаемые блоки.
9. **Использование функциональных компонентов и хуков (Functional Components and Hooks):**
   Используйте функциональные компоненты вместе с хуками для управления состоянием и жизненным циклом.
10. **Обработка ошибок (Error Handling):**
    Обрабатывайте ошибки в компонентах с использованием границ ошибок (Error Boundaries) и уведомлений об ошибках для лучшей отладки.

## _Принципы работы с компонентами_

1. Single Source of Truth (Единый источник истины): Этот принцип гласит, что в приложении должен существовать только один источник данных, от которого зависят все компоненты и которым они манипулируют. Это помогает избежать несогласованности данных и облегчает поддержку и отладку приложения.
2. Immutable Data (Неизменяемые данные): Этот принцип подразумевает, что данные должны быть неизменяемыми, то есть после создания объекта он не может быть изменен. Вместо этого, при необходимости изменений, создается новый объект с обновленными данными. Это помогает избежать неожиданных побочных эффектов и упрощает отслеживание изменений.
3. State Management (Управление состоянием): Этот принцип предполагает, что состояние приложения должно быть централизовано и управляемо. Вместо того, чтобы хранить состояние в различных компонентах, используются инструменты для управления состоянием, такие как Redux или MobX, чтобы обеспечить единообразное и предсказуемое управление состоянием.
4. Unidirectional Data Flow (Однонаправленный поток данных): Этот принцип предписывает, что данные должны перемещаться в одном направлении в приложении, обычно сверху вниз. Вместо того, чтобы компоненты взаимодействовали напрямую друг с другом, они обмениваются данными через свойства (props) и вызывают события для обновления состояния.
5. Separation of Concerns (Разделение ответственности): Этот принцип подразумевает, что каждый компонент должен быть ответственен только за свою специфическую функциональность. Это помогает сделать код более модульным, переиспользуемым и легко поддерживаемым.
6. Predictable State Mutations (Предсказуемые изменения состояния): Этот принцип говорит о том, что изменения состояния должны быть предсказуемыми и легко отслеживаемыми. Желательно использовать чистые функции и неизменяемые операции для обновления состояния, чтобы избежать неожиданных побочных эффектов.

## _setState()_

**setState()** - `иногда` может работать `асинхронно`, поэтому та часть `state` который мы устанавливаем, может установиться/обновиться позже. 

Это реализуется для производительности, тк React может `собрать несколько изменений` `setState` и только потом `перерисовать` элемент `1 раз`. Или может выдать `высший приоритет` для обновления тем `элементам` которые сейчас `видны на экране`.

### _Синтаксис_

```
setState(newState [, callback])
```

- `newState` - `новое состояние компонента`, которое может быть объектом или функцией, возвращающей объект состояния.
- `callback` - `функция` обратного вызова, которая будет `выполнена после обновления состояния`. Это необязательный, но важный параметр, который поможет `избежать асинхронности обновления state` и использования старых значений, например при выполнении внутри одной функции.  

```
this.setState(prev => ({ count: prev.count++ }, () => {
  console.log("Состояние обновлено");
});

```

-> Не верно. `state` не успеет обновиться
```
  handleFilterChange = ({ target }) => {
    const { todoFilter } = target.dataset;
    const { selectedFilter } = this.state;

    this.setState({           /=/ Асинхронный процесс установки значения
      selectedFilter: todoFilter
    });

    switch (selectedFilter) { /=/ Будет использовать старое значение
      case "all":
        break;
      case "active":
        break;
      case "completed":
        break;
    }
  };
```

-> Верно. `state` успеет обновиться
```
   handleFilterChange = ({ target: { dataset } }) => {
    const props = this.props;

    const handleFilterSelection = (state, props) => {
      const { selectedFilter } = state; /=/ Передаем ссылку на state!
																				/=/ А не передаем конкретное старое значение
      switch (selectedFilter) {
        case "all":
          //
          break;
        case "active":
          //
          break;
        case "completed":
          //
          break;
      }
    };

    if (dataset.todoFilter) 
      this.setState({ selectedFilter: dataset.todoFilter }, () =>
        handleFilterSelection(this.state, props) 
        /=/ Передаем callback! А не вызов.
      );
  };
  /=/ Тогда ветвление выполнится с актуальными данными, после обновления state
```
#bugs #async_state 
### _Изменение `state`_

- Необходимо использовать `prevState`, так мы `гарантировано` будем работать с `последним состоянием значения`.
- Так же, `запрещено` изменять `состояние` `напрямую`, используя методы которые мутируют исходные данные.
   React обновляет интерфейс автоматически на основе изменений в состоянии или свойствах компонента. Поэтому, изменение данных `в обход React` может привести к тому, что тот не `заметит изменений` и `не обновит интерфейс` соответствующим образом.
   Кроме того, изменение данных в обход состояния может нарушить принцип единственной истины (`Single Source of Truth`), где `данные должны храниться и обновляться только в одном месте`. 
   Поэтому, нужно `вернуть` все `элементы старого массива`, `кроме` того который нужно `удалить` и поместить эти данные в новый `setState()`

![[Pasted image 20231126140258.png]]

### _Ошибки установки `state`_

- `sort` - мутирует исходный массив, можно избежать через `[...rest]` или [`toSorted()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted)
- `map` - возвращает новый массив, не мутирует. 

-> Такой код будет неверен
```
state = {  
  data: [  
    { name: 'Learn React', active: true },  
    { name: 'Drink Tea', active: false }  
  ]  
};  
  
updateState() {  
  const result = this.state.data.map((el) => {  
    if (el.name === 'Learn React') {  
      el.active = false;  /=/ Изменяет исходный объект
    }  
    return el;  
  });  
  this.setState({ data: result });  
}
```

-> Верная реализация итерации и изменения элементов
```
const result = this.state.data.map((el) => {  
  if (el.name === 'Learn React') {  
    return {         /=/ Создаем новый объект
	    ...el,         /=/ Копируем все поля
	    active: false  /=/ Изменяем нужное поле нового объекта
		}
  }  
  return el;  
});  
```

<iframe width="700" height="300" src="https://www.youtube.com/embed/a2DkRBnp4ns" title="Как правильно обновлять сложный state в React" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

### _Когда использовать `state`_

- Если данные `планируют меняться`, то необходимо использовать  `useState()`/`setState()`
- Если данные` не планируют меняться` и если они даже `не рендерятся`, то использовать `не нужно`

